Mongoose is a \href{https://www.mongodb.org/}{\tt Mongo\+DB} object modeling tool designed to work in an asynchronous environment.

\href{http://slack.mongoosejs.io}{\tt } \href{https://travis-ci.org/Automattic/mongoose}{\tt } \href{http://badge.fury.io/js/mongoose}{\tt }

\href{https://www.npmjs.com/package/mongoose}{\tt }

\subsection*{Documentation}

\href{http://mongoosejs.com/}{\tt mongoosejs.\+com}

\href{https://github.com/Automattic/mongoose/blob/master/History.md#500--2018-01-17}{\tt Mongoose 5.\+0.\+0} was released on January 17, 2018. You can find more details on backwards breaking changes in 5.\+0.\+0 on https\+://github.com/\+Automattic/mongoose/blob/master/migrating\+\_\+to\+\_\+5.\+md \char`\"{}\+Git\+Hub\char`\"{}.

\subsection*{Support}


\begin{DoxyItemize}
\item \href{http://stackoverflow.com/questions/tagged/mongoose}{\tt Stack Overflow}
\item \href{https://github.com/Automattic/mongoose/issues/}{\tt Bug Reports}
\item \href{http://slack.mongoosejs.io/}{\tt Mongoose Slack Channel}
\item \href{http://groups.google.com/group/mongoose-orm}{\tt Help Forum}
\item \href{https://docs.mongodb.org/manual/support/}{\tt Mongo\+DB Support}
\end{DoxyItemize}

\subsection*{Importing}

\`{}\`{}{\ttfamily javascript // Using Node.\+js}require()` const mongoose = require(\textquotesingle{}mongoose');

// Using E\+S6 imports import mongoose from \textquotesingle{}mongoose\textquotesingle{}; \`{}\`{}\`{}

\subsection*{Plugins}

Check out the \href{http://plugins.mongoosejs.io/}{\tt plugins search site} to see hundreds of related modules from the community. Next, learn how to write your own plugin from the \href{http://mongoosejs.com/docs/plugins.html}{\tt docs} or \href{http://thecodebarbarian.com/2015/03/06/guide-to-mongoose-plugins}{\tt this blog post}.

\subsection*{Contributors}

Pull requests are always welcome! Please base pull requests against the {\ttfamily master} branch and follow the https\+://github.com/\+Automattic/mongoose/blob/master/\+C\+O\+N\+T\+R\+I\+B\+U\+T\+I\+N\+G.\+md \char`\"{}contributing guide\char`\"{}.

If your pull requests makes documentation changes, please do {\bfseries not} modify any {\ttfamily .html} files. The {\ttfamily .html} files are compiled code, so please make your changes in {\ttfamily docs/$\ast$.jade}, {\ttfamily lib/$\ast$.js}, or {\ttfamily test/docs/$\ast$.js}.

View all 300+ \href{https://github.com/Automattic/mongoose/graphs/contributors}{\tt contributors}.

\subsection*{Installation}

First install \href{http://nodejs.org/}{\tt node.\+js} and \href{https://www.mongodb.org/downloads}{\tt mongodb}. Then\+:


\begin{DoxyCode}
$ npm install mongoose
\end{DoxyCode}


\subsection*{Overview}

\subsubsection*{Connecting to Mongo\+DB}

First, we need to define a connection. If your app uses only one database, you should use {\ttfamily mongoose.\+connect}. If you need to create additional connections, use {\ttfamily mongoose.\+create\+Connection}.

Both {\ttfamily connect} and {\ttfamily create\+Connection} take a {\ttfamily mongodb\+://} U\+RI, or the parameters {\ttfamily host, database, port, options}.


\begin{DoxyCode}
const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost/my\_database');
\end{DoxyCode}


Once connected, the {\ttfamily open} event is fired on the {\ttfamily Connection} instance. If you\textquotesingle{}re using {\ttfamily mongoose.\+connect}, the {\ttfamily Connection} is {\ttfamily mongoose.\+connection}. Otherwise, {\ttfamily mongoose.\+create\+Connection} return value is a {\ttfamily Connection}.

{\bfseries Note\+:} {\itshape If the local connection fails then try using 127.\+0.\+0.\+1 instead of localhost. Sometimes issues may arise when the local hostname has been changed.}

{\bfseries Important!} Mongoose buffers all the commands until it\textquotesingle{}s connected to the database. This means that you don\textquotesingle{}t have to wait until it connects to Mongo\+DB in order to define models, run queries, etc.

\subsubsection*{Defining a Model}

Models are defined through the {\ttfamily Schema} interface.


\begin{DoxyCode}
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const BlogPost = new Schema(\{
  author: ObjectId,
  title: String,
  body: String,
Â  date: Date
\});
\end{DoxyCode}


Aside from defining the structure of your documents and the types of data you\textquotesingle{}re storing, a Schema handles the definition of\+:


\begin{DoxyItemize}
\item \href{http://mongoosejs.com/docs/validation.html}{\tt Validators} (async and sync)
\item \href{http://mongoosejs.com/docs/api.html#schematype_SchemaType-default}{\tt Defaults}
\item \href{http://mongoosejs.com/docs/api.html#schematype_SchemaType-get}{\tt Getters}
\item \href{http://mongoosejs.com/docs/api.html#schematype_SchemaType-set}{\tt Setters}
\item \href{http://mongoosejs.com/docs/guide.html#indexes}{\tt Indexes}
\item \href{http://mongoosejs.com/docs/middleware.html}{\tt Middleware}
\item \href{http://mongoosejs.com/docs/guide.html#methods}{\tt Methods} definition
\item \href{http://mongoosejs.com/docs/guide.html#statics}{\tt Statics} definition
\item \href{http://mongoosejs.com/docs/plugins.html}{\tt Plugins}
\item \href{http://mongoosejs.com/docs/populate.html}{\tt pseudo-\/\+J\+O\+I\+Ns}
\end{DoxyItemize}

The following example shows some of these features\+:


\begin{DoxyCode}
const Comment = new Schema(\{
  name: \{ type: String, default: 'hahaha' \},
  age: \{ type: Number, min: 18, index: true \},
  bio: \{ type: String, match: /[a-z]/ \},
  date: \{ type: Date, default: Date.now \},
  buff: Buffer
\});

// a setter
Comment.path('name').set(function (v) \{
  return capitalize(v);
\});

// middleware
Comment.pre('save', function (next) \{
  notify(this.get('email'));
  next();
\});
\end{DoxyCode}


Take a look at the example in {\ttfamily examples/schema.\+js} for an end-\/to-\/end example of a typical setup.

\subsubsection*{Accessing a Model}

Once we define a model through `mongoose.\+model(\textquotesingle{}Model\+Name', my\+Schema)\`{}, we can access it through the same function


\begin{DoxyCode}
const myModel = mongoose.model('ModelName');
\end{DoxyCode}


Or just do it all at once


\begin{DoxyCode}
const MyModel = mongoose.model('ModelName', mySchema);
\end{DoxyCode}


The first argument is the {\itshape singular} name of the collection your model is for. {\bfseries Mongoose automatically looks for the {\itshape plural} version of your model name.} For example, if you use


\begin{DoxyCode}
const MyModel = mongoose.model('Ticket', mySchema);
\end{DoxyCode}


Then Mongoose will create the model for your {\bfseries tickets} collection, not your {\bfseries ticket} collection.

Once we have our model, we can then instantiate it, and save it\+:


\begin{DoxyCode}
const instance = new MyModel();
instance.my.key = 'hello';
instance.save(function (err) \{
  //
\});
\end{DoxyCode}


Or we can find documents from the same collection


\begin{DoxyCode}
MyModel.find(\{\}, function (err, docs) \{
  // docs.forEach
\});
\end{DoxyCode}


You can also {\ttfamily find\+One}, {\ttfamily find\+By\+Id}, {\ttfamily update}, etc. For more details check out \href{http://mongoosejs.com/docs/queries.html}{\tt the docs}.

{\bfseries Important!} If you opened a separate connection using {\ttfamily mongoose.\+create\+Connection()} but attempt to access the model through `mongoose.\+model(\textquotesingle{}Model\+Name')\`{} it will not work as expected since it is not hooked up to an active db connection. In this case access your model through the connection you created\+:


\begin{DoxyCode}
const conn = mongoose.createConnection('your connection string');
const MyModel = conn.model('ModelName', schema);
const m = new MyModel;
m.save(); // works
\end{DoxyCode}


vs


\begin{DoxyCode}
const conn = mongoose.createConnection('your connection string');
const MyModel = mongoose.model('ModelName', schema);
const m = new MyModel;
m.save(); // does not work b/c the default connection object was never connected
\end{DoxyCode}


\subsubsection*{Embedded Documents}

In the first example snippet, we defined a key in the Schema that looks like\+:


\begin{DoxyCode}
comments: [Comment]
\end{DoxyCode}


Where {\ttfamily Comment} is a {\ttfamily Schema} we created. This means that creating embedded documents is as simple as\+:


\begin{DoxyCode}
// retrieve my model
var BlogPost = mongoose.model('BlogPost');

// create a blog post
var post = new BlogPost();

// create a comment
post.comments.push(\{ title: 'My comment' \});

post.save(function (err) \{
  if (!err) console.log('Success!');
\});
\end{DoxyCode}


The same goes for removing them\+:


\begin{DoxyCode}
BlogPost.findById(myId, function (err, post) \{
  if (!err) \{
    post.comments[0].remove();
    post.save(function (err) \{
      // do something
    \});
  \}
\});
\end{DoxyCode}


Embedded documents enjoy all the same features as your models. Defaults, validators, middleware. Whenever an error occurs, it\textquotesingle{}s bubbled to the {\ttfamily save()} error callback, so error handling is a snap!

\subsubsection*{Middleware}

See the \href{http://mongoosejs.com/docs/middleware.html}{\tt docs} page.

\paragraph*{Intercepting and mutating method arguments}

You can intercept method arguments via middleware.

For example, this would allow you to broadcast changes about your Documents every time someone {\ttfamily set}s a path in your Document to a new value\+:


\begin{DoxyCode}
schema.pre('set', function (next, path, val, typel) \{
  // `this` is the current Document
  this.emit('set', path, val);

  // Pass control to the next pre
  next();
\});
\end{DoxyCode}


Moreover, you can mutate the incoming {\ttfamily method} arguments so that subsequent middleware see different values for those arguments. To do so, just pass the new values to {\ttfamily next}\+:

\`{}\`{}\`{}js .pre(method, function first\+Pre (next, method\+Arg1, method\+Arg2) \{ // Mutate method\+Arg1 next(\char`\"{}altered-\/\char`\"{} + method\+Arg1.\+to\+String(), method\+Arg2); \});

// pre declaration is chainable .pre(method, function second\+Pre (next, method\+Arg1, method\+Arg2) \{ console.\+log(method\+Arg1); // =$>$ \textquotesingle{}altered-\/original\+Val\+Of\+Method\+Arg1\textquotesingle{}

console.\+log(method\+Arg2); // =$>$ \textquotesingle{}original\+Val\+Of\+Method\+Arg2\textquotesingle{}

// Passing no arguments to {\ttfamily next} automatically passes along the current argument values // i.\+e., the following {\ttfamily next()} is equivalent to {\ttfamily next(method\+Arg1, method\+Arg2)} // and also equivalent to, with the example method arg // values, `next(\textquotesingle{}altered-\/original\+Val\+Of\+Method\+Arg1', \textquotesingle{}original\+Val\+Of\+Method\+Arg2\textquotesingle{})\`{} next(); \}); 
\begin{DoxyCode}
#### Schema gotcha

`type`, when used in a schema has special meaning within Mongoose. If your schema requires using `type` as
       a nested property you must use object notation:

```js
new Schema(\{
  broken: \{ type: Boolean \},
  asset: \{
    name: String,
    type: String // uh oh, it broke. asset will be interpreted as String
  \}
\});

new Schema(\{
  works: \{ type: Boolean \},
  asset: \{
    name: String,
    type: \{ type: String \} // works. asset is an object with a type property
  \}
\});
\end{DoxyCode}


\subsubsection*{Driver Access}

Mongoose is built on top of the \href{https://github.com/mongodb/node-mongodb-native}{\tt official Mongo\+DB Node.\+js driver}. Each mongoose model keeps a reference to a \href{http://mongodb.github.io/node-mongodb-native/2.1/api/Collection.html}{\tt native Mongo\+DB driver collection}. The collection object can be accessed using {\ttfamily Your\+Model.\+collection}. However, using the collection object directly bypasses all mongoose features, including hooks, validation, etc. The one notable exception that {\ttfamily Your\+Model.\+collection} still buffers commands. As such, {\ttfamily Your\+Model.\+collection.\+find()} will {\bfseries not} return a cursor.

\subsection*{A\+PI Docs}

Find the A\+PI docs \href{http://mongoosejs.com/docs/api.html}{\tt here}, generated using \href{https://github.com/tj/dox}{\tt dox} and \href{https://github.com/vkarpov15/acquit}{\tt acquit}.

\subsection*{License}

Copyright (c) 2010 Learn\+Boost $<$\href{mailto:dev@learnboost.com}{\tt dev@learnboost.\+com}$>$

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \textquotesingle{}Software\textquotesingle{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \textquotesingle{}AS IS\textquotesingle{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 