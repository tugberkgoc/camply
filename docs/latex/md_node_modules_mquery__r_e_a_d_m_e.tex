{\ttfamily mquery} is a fluent mongodb query builder designed to run in multiple environments.

\href{https://travis-ci.org/aheckmann/mquery}{\tt } \href{http://badge.fury.io/js/mquery}{\tt }

\href{https://www.npmjs.com/package/mquery}{\tt }

\subsection*{Features}


\begin{DoxyItemize}
\item fluent query builder api
\item custom base query support
\item Mongo\+DB 2.\+4 geo\+J\+S\+ON support
\item method + option combinations validation
\item node.\+js driver compatibility
\item environment detection
\item \href{https://github.com/visionmedia/debug}{\tt debug} support
\item separated collection implementations for maximum flexibility
\end{DoxyItemize}

\subsection*{Use}


\begin{DoxyCode}
require('mongodb').connect(uri, function (err, db) \{
  if (err) return handleError(err);

  // get a collection
  var collection = db.collection('artists');

  // pass it to the constructor
  mquery(collection).find(\{..\}, callback);

  // or pass it to the collection method
  mquery().find(\{..\}).collection(collection).exec(callback)

  // or better yet, create a custom query constructor that has it always set
  var Artist = mquery(collection).toConstructor();
  Artist().find(..).where(..).exec(callback)
\})
\end{DoxyCode}


{\ttfamily mquery} requires a collection object to work with. In the example above we just pass the collection object created using the official \href{https://github.com/mongodb/node-mongodb-native}{\tt Mongo\+DB driver}.

\subsection*{Fluent A\+PI}


\begin{DoxyItemize}
\item \href{#find}{\tt find}
\item \href{#findOne}{\tt find\+One}
\item \href{#count}{\tt count}
\item \href{#remove}{\tt remove}
\item \href{#update}{\tt update}
\item \href{#findoneandupdate}{\tt find\+One\+And\+Update}
\item \href{#findoneandremove}{\tt find\+One\+And\+Delete, find\+One\+And\+Remove}
\item \href{#distinct}{\tt distinct}
\item \href{#exec}{\tt exec}
\item \href{#stream}{\tt stream}
\item \href{#all}{\tt all}
\item \href{#and}{\tt and}
\item \href{#box}{\tt box}
\item \href{#circle}{\tt circle}
\item \href{#elemmatch}{\tt elem\+Match}
\item \href{#equals}{\tt equals}
\item \href{#exists}{\tt exists}
\item \href{#geometry}{\tt geometry}
\item \href{#gt}{\tt gt}
\item \href{#gte}{\tt gte}
\item \href{#in}{\tt in}
\item \href{#intersects}{\tt intersects}
\item \href{#lt}{\tt lt}
\item \href{#lte}{\tt lte}
\item \href{#maxdistance}{\tt max\+Distance}
\item \href{#mod}{\tt mod}
\item \href{#ne}{\tt ne}
\item \href{#nin}{\tt nin}
\item \href{#nor}{\tt nor}
\item \href{#near}{\tt near}
\item \href{#or}{\tt or}
\item \href{#polygon}{\tt polygon}
\item \href{#regex}{\tt regex}
\item \href{#select}{\tt select}
\item \href{#selected}{\tt selected}
\item \href{#selectedinclusively}{\tt selected\+Inclusively}
\item \href{#selectedexclusively}{\tt selected\+Exclusively}
\item \href{#size}{\tt size}
\item \href{#slice}{\tt slice}
\item \href{#within}{\tt within}
\item \href{#where}{\tt where}
\item \href{#where-1}{\tt \$where}
\item \href{#batchsize}{\tt batch\+Size}
\item \href{#collation}{\tt collation}
\item \href{#comment}{\tt comment}
\item \href{#hint}{\tt hint}
\item \href{#j}{\tt j}
\item \href{#limit}{\tt limit}
\item \href{#maxscan}{\tt max\+Scan}
\item \href{#maxtime}{\tt max\+Time, max\+Time\+MS}
\item \href{#skip}{\tt skip}
\item \href{#sort}{\tt sort}
\item \href{#read}{\tt read, set\+Read\+Preference}
\item \href{#readconcern}{\tt read\+Concern, r}
\item \href{#slaveok}{\tt slave\+Ok}
\item \href{#snapshot}{\tt snapshot}
\item \href{#tailable}{\tt tailable}
\item \href{#writeconcern}{\tt write\+Concern, w}
\item \href{#wtimeout}{\tt wtimeout, w\+Timeout}
\end{DoxyItemize}

\subsection*{Helpers}


\begin{DoxyItemize}
\item \href{#collection}{\tt collection}
\item \href{#then}{\tt then}
\item \href{#thunk}{\tt thunk}
\item \href{#mergeobject}{\tt merge}
\item \href{#setoptionsoptions}{\tt set\+Options}
\item \href{#settracefunctionfunc}{\tt set\+Trace\+Function}
\item \href{#mquerysetglobaltracefunctionfunc}{\tt mquery.\+set\+Global\+Trace\+Function}
\item \href{#mquerycanmerge}{\tt mquery.\+can\+Merge}
\item \href{#mqueryusegeowithin}{\tt mquery.\+use\$geo\+Within}
\end{DoxyItemize}

\subsubsection*{find()}

Declares this query a {\itshape find} query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.


\begin{DoxyCode}
mquery().find()
mquery().find(match)
mquery().find(callback)
mquery().find(match, function (err, docs) \{
  assert(Array.isArray(docs));
\})
\end{DoxyCode}


\subsubsection*{find\+One()}

Declares this query a {\itshape find\+One} query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.


\begin{DoxyCode}
mquery().findOne()
mquery().findOne(match)
mquery().findOne(callback)
mquery().findOne(match, function (err, doc) \{
  if (doc) \{
    // the document may not be found
    console.log(doc);
  \}
\})
\end{DoxyCode}


\subsubsection*{count()}

Declares this query a {\itshape count} query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.


\begin{DoxyCode}
mquery().count()
mquery().count(match)
mquery().count(callback)
mquery().count(match, function (err, number)\{
  console.log('we found %d matching documents', number);
\})
\end{DoxyCode}


\subsubsection*{remove()}

Declares this query a {\itshape remove} query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.


\begin{DoxyCode}
mquery().remove()
mquery().remove(match)
mquery().remove(callback)
mquery().remove(match, function (err)\{\})
\end{DoxyCode}


\subsubsection*{update()}

Declares this query an {\itshape update} query. Optionally pass an update document, match clause, options or callback. If a callback is passed, the query is executed. To force execution without passing a callback, run {\ttfamily update(true)}.


\begin{DoxyCode}
mquery().update()
mquery().update(match, updateDocument)
mquery().update(match, updateDocument, options)

// the following all execute the command
mquery().update(callback)
mquery().update(\{$set: updateDocument, callback)
mquery().update(match, updateDocument, callback)
mquery().update(match, updateDocument, options, function (err, result)\{\})
mquery().update(true) // executes (unsafe write)
\end{DoxyCode}


\subparagraph*{the update document}

All paths passed that are not {\ttfamily \$atomic} operations will become {\ttfamily \$set} ops. For example\+:


\begin{DoxyCode}
mquery(collection).where(\{ \_id: id \}).update(\{ title: 'words' \}, callback)
\end{DoxyCode}


becomes


\begin{DoxyCode}
collection.update(\{ \_id: id \}, \{ $set: \{ title: 'words' \}\}, callback)
\end{DoxyCode}


This behavior can be overridden using the {\ttfamily overwrite} option (see below).

\subparagraph*{options}

Options are passed to the {\ttfamily set\+Options()} method.


\begin{DoxyItemize}
\item overwrite
\end{DoxyItemize}

Passing an empty object {\ttfamily \{ \}} as the update document will result in a no-\/op unless the {\ttfamily overwrite} option is passed. Without the {\ttfamily overwrite} option, the update operation will be ignored and the callback executed without sending the command to Mongo\+DB to prevent accidently overwritting documents in the collection.


\begin{DoxyCode}
var q = mquery(collection).where(\{ \_id: id \}).setOptions(\{ overwrite: true \});
q.update(\{ \}, callback); // overwrite with an empty doc
\end{DoxyCode}


The {\ttfamily overwrite} option isn\textquotesingle{}t just for empty objects, it also provides a means to override the default {\ttfamily \$set} conversion and send the update document as is.


\begin{DoxyCode}
// create a base query
var base = mquery(\{ \_id: 108 \}).collection(collection).toConstructor();

base().findOne(function (err, doc) \{
  console.log(doc); // \{ \_id: 108, name: 'cajon' \})

  base().setOptions(\{ overwrite: true \}).update(\{ changed: true \}, function (err) \{
    base.findOne(function (err, doc) \{
      console.log(doc); // \{ \_id: 108, changed: true \}) - the doc was overwritten
    \});
  \});
\})
\end{DoxyCode}



\begin{DoxyItemize}
\item multi
\end{DoxyItemize}

Updates only modify a single document by default. To update multiple documents, set the {\ttfamily multi} option to {\ttfamily true}.


\begin{DoxyCode}
mquery()
  .collection(coll)
  .update(\{ name: /^match/ \}, \{ $addToSet: \{ arr: 4 \}\}, \{ multi: true \}, callback)

// another way of doing it
mquery(\{ name: /^match/ \})
  .collection(coll)
  .setOptions(\{ multi: true \})
  .update(\{ $addToSet: \{ arr: 4 \}\}, callback)

// update multiple documents with an empty doc
var q = mquery(collection).where(\{ name: /^match/ \});
q.setOptions(\{ multi: true, overwrite: true \})
q.update(\{ \});
q.update(function (err, result) \{
  console.log(arguments);
\});
\end{DoxyCode}


\subsubsection*{find\+One\+And\+Update()}

Declares this query a {\itshape find\+And\+Modify} with update query. Optionally pass a match clause, update document, options, or callback. If a callback is passed, the query is executed.

When executed, the first matching document (if found) is modified according to the update document and passed back to the callback.

\subparagraph*{options}

Options are passed to the {\ttfamily set\+Options()} method.


\begin{DoxyItemize}
\item {\ttfamily new}\+: boolean -\/ true to return the modified document rather than the original. defaults to true
\item {\ttfamily upsert}\+: boolean -\/ creates the object if it doesn\textquotesingle{}t exist. defaults to false
\item {\ttfamily sort}\+: if multiple docs are found by the match condition, sets the sort order to choose which doc to update
\end{DoxyItemize}


\begin{DoxyCode}
query.findOneAndUpdate()
query.findOneAndUpdate(updateDocument)
query.findOneAndUpdate(match, updateDocument)
query.findOneAndUpdate(match, updateDocument, options)

// the following all execute the command
query.findOneAndUpdate(callback)
query.findOneAndUpdate(updateDocument, callback)
query.findOneAndUpdate(match, updateDocument, callback)
query.findOneAndUpdate(match, updateDocument, options, function (err, doc) \{
  if (doc) \{
    // the document may not be found
    console.log(doc);
  \}
\})
\end{DoxyCode}


\subsubsection*{find\+One\+And\+Remove()}

Declares this query a {\itshape find\+And\+Modify} with remove query. Alias of find\+One\+And\+Delete. Optionally pass a match clause, options, or callback. If a callback is passed, the query is executed.

When executed, the first matching document (if found) is modified according to the update document, removed from the collection and passed to the callback.

\subparagraph*{options}

Options are passed to the {\ttfamily set\+Options()} method.


\begin{DoxyItemize}
\item {\ttfamily sort}\+: if multiple docs are found by the condition, sets the sort order to choose which doc to modify and remove
\end{DoxyItemize}


\begin{DoxyCode}
A.where().findOneAndDelete()
A.where().findOneAndRemove()
A.where().findOneAndRemove(match)
A.where().findOneAndRemove(match, options)

// the following all execute the command
A.where().findOneAndRemove(callback)
A.where().findOneAndRemove(match, callback)
A.where().findOneAndRemove(match, options, function (err, doc) \{
  if (doc) \{
    // the document may not be found
    console.log(doc);
  \}
\})
\end{DoxyCode}


\subsubsection*{distinct()}

Declares this query a {\itshape distinct} query. Optionally pass the distinct field, a match clause or callback. If a callback is passed the query is executed.


\begin{DoxyCode}
mquery().distinct()
mquery().distinct(match)
mquery().distinct(match, field)
mquery().distinct(field)

// the following all execute the command
mquery().distinct(callback)
mquery().distinct(field, callback)
mquery().distinct(match, callback)
mquery().distinct(match, field, function (err, result) \{
  console.log(result);
\})
\end{DoxyCode}


\subsubsection*{exec()}

Executes the query.


\begin{DoxyCode}
mquery().findOne().where('route').intersects(polygon).exec(function (err, docs)\{\})
\end{DoxyCode}


\subsubsection*{stream()}

Executes the query and returns a stream.


\begin{DoxyCode}
var stream = mquery().find().stream(options);
stream.on('data', cb);
stream.on('close', fn);
\end{DoxyCode}


Note\+: this only works with {\ttfamily find()} operations.

Note\+: returns the stream object directly from the node-\/mongodb-\/native driver. (currently streams1 type stream). Any options will be passed along to the \href{http://mongodb.github.io/node-mongodb-native/api-generated/cursor.html#stream}{\tt driver method}. 



\subsubsection*{all()}

Specifies an {\ttfamily \$all} query condition


\begin{DoxyCode}
mquery().where('permission').all(['read', 'write'])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/all/}{\tt Mongo\+DB documentation}

\subsubsection*{and()}

Specifies arguments for an {\ttfamily \$and} condition


\begin{DoxyCode}
mquery().and([\{ color: 'green' \}, \{ status: 'ok' \}])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/and/}{\tt Mongo\+DB documentation}

\subsubsection*{box()}

Specifies a {\ttfamily \$box} condition


\begin{DoxyCode}
var lowerLeft = [40.73083, -73.99756]
var upperRight= [40.741404,  -73.988135]

mquery().where('location').within().box(lowerLeft, upperRight)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/box/}{\tt Mongo\+DB Documentation}

\subsubsection*{circle()}

Specifies a {\ttfamily \$center} or {\ttfamily \$center\+Sphere} condition.


\begin{DoxyCode}
var area = \{ center: [50, 50], radius: 10, unique: true \}
query.where('loc').within().circle(area)
query.circle('loc', area);

// for spherical calculations
var area = \{ center: [50, 50], radius: 10, unique: true, spherical: true \}
query.where('loc').within().circle(area)
query.circle('loc', area);
\end{DoxyCode}



\begin{DoxyItemize}
\item \href{http://docs.mongodb.org/manual/reference/operator/center/}{\tt Mongo\+DB Documentation -\/ center}
\item \href{http://docs.mongodb.org/manual/reference/operator/centerSphere/}{\tt Mongo\+DB Documentation -\/ center\+Sphere}
\end{DoxyItemize}

\subsubsection*{elem\+Match()}

Specifies an {\ttfamily \$elem\+Match} condition


\begin{DoxyCode}
query.where('comment').elemMatch(\{ author: 'autobot', votes: \{$gte: 5\}\})

query.elemMatch('comment', function (elem) \{
  elem.where('author').equals('autobot');
  elem.where('votes').gte(5);
\})
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/elemMatch/}{\tt Mongo\+DB Documentation}

\subsubsection*{equals()}

Specifies the complementary comparison value for the path specified with {\ttfamily where()}.


\begin{DoxyCode}
mquery().where('age').equals(49);

// is the same as

mquery().where(\{ 'age': 49 \});
\end{DoxyCode}


\subsubsection*{exists()}

Specifies an {\ttfamily \$exists} condition


\begin{DoxyCode}
// \{ name: \{ $exists: true \}\}
mquery().where('name').exists()
mquery().where('name').exists(true)
mquery().exists('name')

// \{ name: \{ $exists: false \}\}
mquery().where('name').exists(false);
mquery().exists('name', false);
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/exists/}{\tt Mongo\+DB Documentation}

\subsubsection*{geometry()}

Specifies a {\ttfamily \$geometry} condition


\begin{DoxyCode}
var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
query.where('loc').within().geometry(\{ type: 'Polygon', coordinates: polyA \})

// or
var polyB = [[ 0, 0 ], [ 1, 1 ]]
query.where('loc').within().geometry(\{ type: 'LineString', coordinates: polyB \})

// or
var polyC = [ 0, 0 ]
query.where('loc').within().geometry(\{ type: 'Point', coordinates: polyC \})

// or
query.where('loc').intersects().geometry(\{ type: 'Point', coordinates: polyC \})

// or
query.where('loc').near().geometry(\{ type: 'Point', coordinates: [3,5] \})
\end{DoxyCode}


{\ttfamily geometry()} {\bfseries must} come after {\ttfamily intersects()}, {\ttfamily within()}, or {\ttfamily near()}.

The {\ttfamily object} argument must contain {\ttfamily type} and {\ttfamily coordinates} properties.


\begin{DoxyItemize}
\item type {\ttfamily String}
\item coordinates {\ttfamily Array}
\end{DoxyItemize}

\href{http://docs.mongodb.org/manual/reference/operator/geometry/}{\tt Mongo\+DB Documentation}

\subsubsection*{gt()}

Specifies a {\ttfamily \$gt} query condition.


\begin{DoxyCode}
mquery().where('clicks').gt(999)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/gt/}{\tt Mongo\+DB Documentation}

\subsubsection*{gte()}

Specifies a {\ttfamily \$gte} query condition.

\href{http://docs.mongodb.org/manual/reference/operator/gte/}{\tt Mongo\+DB Documentation}


\begin{DoxyCode}
mquery().where('clicks').gte(1000)
\end{DoxyCode}


\subsubsection*{in()}

Specifies an {\ttfamily \$in} query condition.


\begin{DoxyCode}
mquery().where('author\_id').in([3, 48901, 761])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/in/}{\tt Mongo\+DB Documentation}

\subsubsection*{intersects()}

Declares an {\ttfamily \$geo\+Intersects} query for {\ttfamily geometry()}.


\begin{DoxyCode}
query.where('path').intersects().geometry(\{
    type: 'LineString'
  , coordinates: [[180.0, 11.0], [180, 9.0]]
\})

// geometry arguments are supported
query.where('path').intersects(\{
    type: 'LineString'
  , coordinates: [[180.0, 11.0], [180, 9.0]]
\})
\end{DoxyCode}


{\bfseries Must} be used after {\ttfamily where()}.

\href{http://docs.mongodb.org/manual/reference/operator/geoIntersects/}{\tt Mongo\+DB Documentation}

\subsubsection*{lt()}

Specifies a {\ttfamily \$lt} query condition.


\begin{DoxyCode}
mquery().where('clicks').lt(50)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/lt/}{\tt Mongo\+DB Documentation}

\subsubsection*{lte()}

Specifies a {\ttfamily \$lte} query condition.


\begin{DoxyCode}
mquery().where('clicks').lte(49)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/lte/}{\tt Mongo\+DB Documentation}

\subsubsection*{max\+Distance()}

Specifies a {\ttfamily \$max\+Distance} query condition.


\begin{DoxyCode}
mquery().where('location').near(\{ center: [139, 74.3] \}).maxDistance(5)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/maxDistance/}{\tt Mongo\+DB Documentation}

\subsubsection*{mod()}

Specifies a {\ttfamily \$mod} condition


\begin{DoxyCode}
mquery().where('count').mod(2, 0)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/mod/}{\tt Mongo\+DB Documentation}

\subsubsection*{ne()}

Specifies a {\ttfamily \$ne} query condition.


\begin{DoxyCode}
mquery().where('status').ne('ok')
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/ne/}{\tt Mongo\+DB Documentation}

\subsubsection*{nin()}

Specifies an {\ttfamily \$nin} query condition.


\begin{DoxyCode}
mquery().where('author\_id').nin([3, 48901, 761])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/nin/}{\tt Mongo\+DB Documentation}

\subsubsection*{nor()}

Specifies arguments for an {\ttfamily \$nor} condition.


\begin{DoxyCode}
mquery().nor([\{ color: 'green' \}, \{ status: 'ok' \}])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/nor/}{\tt Mongo\+DB Documentation}

\subsubsection*{near()}

Specifies arguments for a {\ttfamily \$near} or {\ttfamily \$near\+Sphere} condition.

These operators return documents sorted by distance.

\paragraph*{Example}


\begin{DoxyCode}
query.where('loc').near(\{ center: [10, 10] \});
query.where('loc').near(\{ center: [10, 10], maxDistance: 5 \});
query.near('loc', \{ center: [10, 10], maxDistance: 5 \});

// GeoJSON
query.where('loc').near(\{ center: \{ type: 'Point', coordinates: [10, 10] \}\});
query.where('loc').near(\{ center: \{ type: 'Point', coordinates: [10, 10] \}, maxDistance: 5, spherical: true
       \});
query.where('loc').near().geometry(\{ type: 'Point', coordinates: [10, 10] \});

// For a $nearSphere condition, pass the `spherical` option.
query.near(\{ center: [10, 10], maxDistance: 5, spherical: true \});
\end{DoxyCode}


\href{http://www.mongodb.org/display/DOCS/Geospatial+Indexing}{\tt Mongo\+DB Documentation}

\subsubsection*{or()}

Specifies arguments for an {\ttfamily \$or} condition.


\begin{DoxyCode}
mquery().or([\{ color: 'red' \}, \{ status: 'emergency' \}])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/or/}{\tt Mongo\+DB Documentation}

\subsubsection*{polygon()}

Specifies a {\ttfamily \$polygon} condition


\begin{DoxyCode}
mquery().where('loc').within().polygon([10,20], [13, 25], [7,15])
mquery().polygon('loc', [10,20], [13, 25], [7,15])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/polygon/}{\tt Mongo\+DB Documentation}

\subsubsection*{regex()}

Specifies a {\ttfamily \$regex} query condition.


\begin{DoxyCode}
mquery().where('name').regex(/^sixstepsrecords/)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/regex/}{\tt Mongo\+DB Documentation}

\subsubsection*{select()}

Specifies which document fields to include or exclude


\begin{DoxyCode}
// 1 means include, 0 means exclude
mquery().select(\{ name: 1, address: 1, \_id: 0 \})

// or

mquery().select('name address -\_id')
\end{DoxyCode}


\subparagraph*{String syntax}

When passing a string, prefixing a path with {\ttfamily -\/} will flag that path as excluded. When a path does not have the {\ttfamily -\/} prefix, it is included.


\begin{DoxyCode}
// include a and b, exclude c
query.select('a b -c');

// or you may use object notation, useful when
// you have keys already prefixed with a "-"
query.select(\{a: 1, b: 1, c: 0\});
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\subsubsection*{selected()}

Determines if the query has selected any fields.


\begin{DoxyCode}
var query = mquery();
query.selected() // false
query.select('-name');
query.selected() // true
\end{DoxyCode}


\subsubsection*{selected\+Inclusively()}

Determines if the query has selected any fields inclusively.


\begin{DoxyCode}
var query = mquery().select('name');
query.selectedInclusively() // true

var query = mquery();
query.selected() // false
query.select('-name');
query.selectedInclusively() // false
query.selectedExclusively() // true
\end{DoxyCode}


\subsubsection*{selected\+Exclusively()}

Determines if the query has selected any fields exclusively.


\begin{DoxyCode}
var query = mquery().select('-name');
query.selectedExclusively() // true

var query = mquery();
query.selected() // false
query.select('name');
query.selectedExclusively() // false
query.selectedInclusively() // true
\end{DoxyCode}


\subsubsection*{size()}

Specifies a {\ttfamily \$size} query condition.


\begin{DoxyCode}
mquery().where('someArray').size(6)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/operator/size/}{\tt Mongo\+DB Documentation}

\subsubsection*{slice()}

Specifies a {\ttfamily \$slice} projection for a {\ttfamily path}


\begin{DoxyCode}
mquery().where('comments').slice(5)
mquery().where('comments').slice(-5)
mquery().where('comments').slice([-10, 5])
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/projection/slice/}{\tt Mongo\+DB Documentation}

\subsubsection*{within()}

Sets a {\ttfamily \$geo\+Within} or {\ttfamily \$within} argument for geo-\/spatial queries.


\begin{DoxyCode}
mquery().within().box()
mquery().within().circle()
mquery().within().geometry()

mquery().where('loc').within(\{ center: [50,50], radius: 10, unique: true, spherical: true \});
mquery().where('loc').within(\{ box: [[40.73, -73.9], [40.7, -73.988]] \});
mquery().where('loc').within(\{ polygon: [[],[],[],[]] \});

mquery().where('loc').within([], [], []) // polygon
mquery().where('loc').within([], []) // box
mquery().where('loc').within(\{ type: 'LineString', coordinates: [...] \}); // geometry
\end{DoxyCode}


As of mquery 2.\+0, {\ttfamily \$geo\+Within} is used by default. This impacts you if running Mongo\+DB $<$ 2.\+4. To alter this behavior, see \href{#mqueryusegeowithin}{\tt mquery.\+use\$geo\+Within}.

{\bfseries Must} be used after {\ttfamily where()}.

\href{http://docs.mongodb.org/manual/reference/operator/geoWithin/}{\tt Mongo\+DB Documentation}

\subsubsection*{where()}

Specifies a {\ttfamily path} for use with chaining


\begin{DoxyCode}
// instead of writing:
mquery().find(\{age: \{$gte: 21, $lte: 65\}\});

// we can instead write:
mquery().where('age').gte(21).lte(65);

// passing query conditions is permitted too
mquery().find().where(\{ name: 'vonderful' \})

// chaining
mquery()
.where('age').gte(21).lte(65)
.where(\{ 'name': /^vonderful/i \})
.where('friends').slice(10)
.exec(callback)
\end{DoxyCode}


\subsubsection*{\$where()}

Specifies a {\ttfamily \$where} condition.

Use {\ttfamily \$where} when you need to select documents using a Java\+Script expression.


\begin{DoxyCode}
query.$where('this.comments.length > 10 || this.name.length > 5').exec(callback)

query.$where(function () \{
  return this.comments.length > 10 || this.name.length > 5;
\})
\end{DoxyCode}


Only use {\ttfamily \$where} when you have a condition that cannot be met using other Mongo\+DB operators like {\ttfamily \$lt}. Be sure to read about all of \href{http://docs.mongodb.org/manual/reference/operator/where/}{\tt its caveats} before using. 



\subsubsection*{batch\+Size()}

Specifies the batch\+Size option.


\begin{DoxyCode}
query.batchSize(100)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/method/cursor.batchSize/}{\tt Mongo\+DB documentation}

\subsubsection*{collation()}

Specifies the collation option.


\begin{DoxyCode}
query.collation(\{ locale: "en\_US", strength: 1 \})
\end{DoxyCode}


\href{https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation}{\tt Mongo\+DB documentation}

\subsubsection*{comment()}

Specifies the comment option.


\begin{DoxyCode}
query.comment('login query');
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/operator/}{\tt Mongo\+DB documentation}

\subsubsection*{hint()}

Sets query hints.


\begin{DoxyCode}
mquery().hint(\{ indexA: 1, indexB: -1 \})
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/operator/hint/}{\tt Mongo\+DB documentation}

\subsubsection*{j()}

Requests acknowledgement that this operation has been persisted to Mongo\+DB\textquotesingle{}s on-\/disk journal.

This option is only valid for operations that write to the database\+:


\begin{DoxyItemize}
\item {\ttfamily delete\+One()}
\item {\ttfamily delete\+Many()}
\item {\ttfamily find\+One\+And\+Delete()}
\item {\ttfamily find\+One\+And\+Update()}
\item {\ttfamily remove()}
\item {\ttfamily update()}
\item {\ttfamily update\+One()}
\item {\ttfamily update\+Many()}
\end{DoxyItemize}

Defaults to the {\ttfamily j} value if it is specified in \href{#writeconcern}{\tt write\+Concern}


\begin{DoxyCode}
mquery().j(true);
\end{DoxyCode}


\subsubsection*{limit()}

Specifies the limit option.


\begin{DoxyCode}
query.limit(20)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/method/cursor.limit/}{\tt Mongo\+DB documentation}

\subsubsection*{max\+Scan()}

Specifies the max\+Scan option.


\begin{DoxyCode}
query.maxScan(100)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/operator/maxScan/}{\tt Mongo\+DB documentation}

\subsubsection*{max\+Time()}

Specifies the max\+Time\+MS option.


\begin{DoxyCode}
query.maxTime(100)
query.maxTimeMS(100)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/method/cursor.maxTimeMS/}{\tt Mongo\+DB documentation}

\subsubsection*{skip()}

Specifies the skip option.


\begin{DoxyCode}
query.skip(100).limit(20)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/method/cursor.skip/}{\tt Mongo\+DB documentation}

\subsubsection*{sort()}

Sets the query sort order.

If an object is passed, key values allowed are {\ttfamily asc}, {\ttfamily desc}, {\ttfamily ascending}, {\ttfamily descending}, {\ttfamily 1}, and {\ttfamily -\/1}.

If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with {\ttfamily -\/} which will be treated as descending.


\begin{DoxyCode}
// these are equivalent
query.sort(\{ field: 'asc', test: -1 \});
query.sort('field -test');
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/method/cursor.sort/}{\tt Mongo\+DB documentation}

\subsubsection*{read()}

Sets the read\+Preference option for the query.


\begin{DoxyCode}
mquery().read('primary')
mquery().read('p')  // same as primary

mquery().read('primaryPreferred')
mquery().read('pp') // same as primaryPreferred

mquery().read('secondary')
mquery().read('s')  // same as secondary

mquery().read('secondaryPreferred')
mquery().read('sp') // same as secondaryPreferred

mquery().read('nearest')
mquery().read('n')  // same as nearest

mquery().setReadPreference('primary') // alias of .read()
\end{DoxyCode}


\subparagraph*{Preferences\+:}


\begin{DoxyItemize}
\item {\ttfamily primary} -\/ (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
\item {\ttfamily secondary} -\/ Read from secondary if available, otherwise error.
\item {\ttfamily primary\+Preferred} -\/ Read from primary if available, otherwise a secondary.
\item {\ttfamily secondary\+Preferred} -\/ Read from a secondary if available, otherwise read from the primary.
\item {\ttfamily nearest} -\/ All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
\end{DoxyItemize}

Aliases


\begin{DoxyItemize}
\item {\ttfamily p} primary
\item {\ttfamily pp} primary\+Preferred
\item {\ttfamily s} secondary
\item {\ttfamily sp} secondary\+Preferred
\item {\ttfamily n} nearest
\end{DoxyItemize}

\subparagraph*{Preference Tags\+:}

To keep the separation of concerns between {\ttfamily mquery} and your driver clean, {\ttfamily mquery\+::read()} no longer handles specifying a second {\ttfamily tags} argument as of version 0.\+5. If you need to specify tags, pass any non-\/string argument as the first argument. {\ttfamily mquery} will pass this argument untouched to your collections methods later. For example\+:


\begin{DoxyCode}
// example of specifying tags using the Node.js driver
var ReadPref = require('mongodb').ReadPreference;
var preference = new ReadPref('secondary', [\{ dc:'sf', s: 1 \},\{ dc:'ma', s: 2 \}]);
mquery(..).read(preference).exec();
\end{DoxyCode}


Read more about how to use read preferences \href{http://docs.mongodb.org/manual/applications/replication/#read-preference}{\tt here} and \href{http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences}{\tt here}.

\subsubsection*{read\+Concern()}

Sets the read\+Concern option for the query.


\begin{DoxyCode}
// local
mquery().readConcern('local')
mquery().readConcern('l')
mquery().r('l')

// available
mquery().readConcern('available')
mquery().readConcern('a')
mquery().r('a')

// majority
mquery().readConcern('majority')
mquery().readConcern('m')
mquery().r('m')

// linearizable
mquery().readConcern('linearizable')
mquery().readConcern('lz')
mquery().r('lz')

// snapshot
mquery().readConcern('snapshot')
mquery().readConcern('s')
mquery().r('s')
\end{DoxyCode}


\subparagraph*{Read Concern Level\+:}


\begin{DoxyItemize}
\item {\ttfamily local} -\/ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.\+e. may be rolled back). (Mongo\+DB 3.\+2+)
\item {\ttfamily available} -\/ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.\+e. may be rolled back). (Mongo\+DB 3.\+6+)
\item {\ttfamily majority} -\/ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure. (Mongo\+DB 3.\+2+)
\item {\ttfamily linearizable} -\/ The query returns data that reflects all successful majority-\/acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results. (Mongo\+DB 3.\+4+)
\item {\ttfamily snapshot} -\/ Only available for operations within multi-\/document transactions. Upon transaction commit with write concern \char`\"{}majority\char`\"{}, the transaction operations are guaranteed to have read from a snapshot of majority-\/committed data. (Mongo\+DB 4.\+0+)
\end{DoxyItemize}

Aliases


\begin{DoxyItemize}
\item {\ttfamily l} local
\item {\ttfamily a} available
\item {\ttfamily m} majority
\item {\ttfamily lz} linearizable
\item {\ttfamily s} snapshot
\end{DoxyItemize}

Read more about how to use read concern \href{https://docs.mongodb.com/manual/reference/read-concern/}{\tt here}.

\subsubsection*{write\+Concern()}

Sets the write\+Concern option for the query.

This option is only valid for operations that write to the database\+:


\begin{DoxyItemize}
\item {\ttfamily delete\+One()}
\item {\ttfamily delete\+Many()}
\item {\ttfamily find\+One\+And\+Delete()}
\item {\ttfamily find\+One\+And\+Update()}
\item {\ttfamily remove()}
\item {\ttfamily update()}
\item {\ttfamily update\+One()}
\item {\ttfamily update\+Many()}
\end{DoxyItemize}


\begin{DoxyCode}
mquery().writeConcern(0)
mquery().writeConcern(1)
mquery().writeConcern(\{ w: 1, j: true, wtimeout: 2000 \})
mquery().writeConcern('majority')
mquery().writeConcern('m') // same as majority
mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern(\{ w: 'm' \}) instead
mquery().w(1) // w is alias of writeConcern
\end{DoxyCode}


\subparagraph*{Write Concern\+:}

write\+Concern(\{ w\+: {\ttfamily $<$value$>$}, j\+: {\ttfamily $<$boolean$>$}, wtimeout\+: {\ttfamily $<$number$>$} \}\`{})


\begin{DoxyItemize}
\item the w option to request acknowledgement that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags
\item the j option to request acknowledgement that the write operation has been written to the journal
\item the wtimeout option to specify a time limit to prevent write operations from blocking indefinitely
\end{DoxyItemize}

Can be break down to use the following syntax\+:

mquery().w({\ttfamily $<$value$>$}).j({\ttfamily $<$boolean$>$}).wtimeout({\ttfamily $<$number$>$})

Read more about how to use write concern \href{https://docs.mongodb.com/manual/reference/write-concern/}{\tt here}

\subsubsection*{slave\+Ok()}

Sets the slave\+Ok option. {\ttfamily true} allows reading from secondaries.

{\bfseries deprecated} use \href{#read}{\tt read()} preferences instead if on mongodb $>$= 2.\+2


\begin{DoxyCode}
query.slaveOk() // true
query.slaveOk(true)
query.slaveOk(false)
\end{DoxyCode}


\href{http://docs.mongodb.org/manual/reference/method/rs.slaveOk/}{\tt Mongo\+DB documentation}

\subsubsection*{snapshot()}

Specifies this query as a snapshot query.


\begin{DoxyCode}
mquery().snapshot() // true
mquery().snapshot(true)
mquery().snapshot(false)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/reference/operator/snapshot/}{\tt Mongo\+DB documentation}

\subsubsection*{tailable()}

Sets tailable option.


\begin{DoxyCode}
mquery().tailable() <== true
mquery().tailable(true)
mquery().tailable(false)
\end{DoxyCode}


{\itshape Cannot be used with {\ttfamily distinct()}.}

\href{http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/}{\tt Mongo\+DB Documentation}

\subsubsection*{wtimeout()}

Specifies a time limit, in milliseconds, for the write concern. If {\ttfamily w $>$ 1}, it is maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is {\ttfamily 0}, which means no timeout.

This option is only valid for operations that write to the database\+:


\begin{DoxyItemize}
\item {\ttfamily delete\+One()}
\item {\ttfamily delete\+Many()}
\item {\ttfamily find\+One\+And\+Delete()}
\item {\ttfamily find\+One\+And\+Update()}
\item {\ttfamily remove()}
\item {\ttfamily update()}
\item {\ttfamily update\+One()}
\item {\ttfamily update\+Many()}
\end{DoxyItemize}

Defaults to {\ttfamily wtimeout} value if it is specified in \href{#writeconcern}{\tt write\+Concern}


\begin{DoxyCode}
mquery().wtimeout(2000)
mquery().wTimeout(2000)
\end{DoxyCode}


\subsection*{Helpers}

\subsubsection*{collection()}

Sets the querys collection.


\begin{DoxyCode}
mquery().collection(aCollection)
\end{DoxyCode}


\subsubsection*{then()}

Executes the query and returns a promise which will be resolved with the query results or rejected if the query responds with an error.


\begin{DoxyCode}
mquery().find(..).then(success, error);
\end{DoxyCode}


This is very useful when combined with \href{https://github.com/visionmedia/co}{\tt co} or \href{https://github.com/koajs/koa}{\tt koa}, which automatically resolve promise-\/like objects for you.


\begin{DoxyCode}
co(function*()\{
  var doc = yield mquery().findOne(\{ \_id: 499 \});
  console.log(doc); // \{ \_id: 499, name: 'amazing', .. \}
\})();
\end{DoxyCode}


{\itshape N\+O\+TE}\+: The returned promise is a \href{https://github.com/petkaantonov/bluebird/}{\tt bluebird} promise but this is customizable. If you want to use your favorite promise library, simply set {\ttfamily mquery.\+Promise = Your\+Promise\+Constructor}. Your {\ttfamily Promise} must be \href{http://promisesaplus.com/}{\tt promises A+} compliant.

\subsubsection*{thunk()}

Returns a thunk which when called runs the query\textquotesingle{}s {\ttfamily exec} method passing the results to the callback.


\begin{DoxyCode}
var thunk = mquery(collection).find(\{..\}).thunk();

thunk(function(err, results) \{

\})
\end{DoxyCode}


\subsubsection*{merge(object)}

Merges other mquery or match condition objects into this one. When an mquery instance is passed, its match conditions, field selection and options are merged.


\begin{DoxyCode}
var drum = mquery(\{ type: 'drum' \}).collection(instruments);
var redDrum = mquery(\{ color: 'red' \}).merge(drum);
redDrum.count(function (err, n) \{
  console.log('there are %d red drums', n);
\})
\end{DoxyCode}


Internally uses {\ttfamily mquery.\+can\+Merge} to determine validity.

\subsubsection*{set\+Options(options)}

Sets query options.


\begin{DoxyCode}
mquery().setOptions(\{ collection: coll, limit: 20 \})
\end{DoxyCode}


\subparagraph*{options}


\begin{DoxyItemize}
\item \href{#tailable}{\tt tailable} $\ast$
\item \href{#sort}{\tt sort} $\ast$
\item \href{#limit}{\tt limit} $\ast$
\item \href{#skip}{\tt skip} $\ast$
\item \href{#maxscan}{\tt max\+Scan} $\ast$
\item \href{#maxtime}{\tt max\+Time} $\ast$
\item \href{#batchSize}{\tt batch\+Size} $\ast$
\item \href{#comment}{\tt comment} $\ast$
\item \href{#snapshot}{\tt snapshot} $\ast$
\item \href{#hint}{\tt hint} $\ast$
\item \href{#slaveOk}{\tt slave\+Ok} $\ast$
\item \href{http://docs.mongodb.org/manual/reference/write-concern/}{\tt safe}\+: Boolean -\/ passed through to the collection. Setting to {\ttfamily true} is equivalent to {\ttfamily \{ w\+: 1 \}}
\item \href{#collection}{\tt collection}\+: the collection to query against
\end{DoxyItemize}

{\itshape $\ast$ denotes a query helper method is also available}

\subsubsection*{set\+Trace\+Function(func)}

Set a function to trace this query. Useful for profiling or logging.


\begin{DoxyCode}
function traceFunction (method, queryInfo, query) \{
  console.log('starting ' + method + ' query');

  return function (err, result, millis) \{
    console.log('finished ' + method + ' query in ' + millis + 'ms');
  \};
\}

mquery().setTraceFunction(traceFunction).findOne(\{name: 'Joe'\}, cb);
\end{DoxyCode}


The trace function is passed (method, query\+Info, query)


\begin{DoxyItemize}
\item method is the name of the method being called (e.\+g. find\+One)
\item query\+Info contains information about the query\+:
\begin{DoxyItemize}
\item conditions\+: query conditions/criteria
\item options\+: options such as sort, fields, etc
\item doc\+: document being updated
\end{DoxyItemize}
\item query is the query object
\end{DoxyItemize}

The trace function should return a callback function which accepts\+:
\begin{DoxyItemize}
\item err\+: error, if any
\item result\+: result, if any
\item millis\+: time spent waiting for query result
\end{DoxyItemize}

N\+O\+TE\+: stream requests are not traced.

\subsubsection*{mquery.\+set\+Global\+Trace\+Function(func)}

Similar to {\ttfamily set\+Trace\+Function()} but automatically applied to all queries.


\begin{DoxyCode}
mquery.setTraceFunction(traceFunction);
\end{DoxyCode}


\subsubsection*{mquery.\+can\+Merge(conditions)}

Determines if {\ttfamily conditions} can be merged using {\ttfamily mquery().merge()}.


\begin{DoxyCode}
var query = mquery(\{ type: 'drum' \});
var okToMerge = mquery.canMerge(anObject)
if (okToMerge) \{
  query.merge(anObject);
\}
\end{DoxyCode}


\subsection*{mquery.\+use\$geo\+Within}

Mongo\+DB 2.\+4 introduced the {\ttfamily \$geo\+Within} operator which replaces and is 100\% backward compatible with {\ttfamily \$within}. As of mquery 0.\+2, we default to using {\ttfamily \$geo\+Within} for all {\ttfamily within()} calls.

If you are running Mongo\+DB $<$ 2.\+4 this will be problematic. To force {\ttfamily mquery} to be backward compatible and always use {\ttfamily \$within}, set the {\ttfamily mquery.\+use\$geo\+Within} flag to {\ttfamily false}.


\begin{DoxyCode}
mquery.use$geoWithin = false;
\end{DoxyCode}


\subsection*{Custom Base Queries}

Often times we want custom base queries that encapsulate predefined criteria. With {\ttfamily mquery} this is easy. First create the query you want to reuse and call its {\ttfamily to\+Constructor()} method which returns a new subclass of {\ttfamily mquery} that retains all options and criteria of the original.


\begin{DoxyCode}
var greatMovies = mquery(movieCollection).where('rating').gte(4.5).toConstructor();

// use it!
greatMovies().count(function (err, n) \{
  console.log('There are %d great movies', n);
\});

greatMovies().where(\{ name: /^Life/ \}).select('name').find(function (err, docs) \{
  console.log(docs);
\});
\end{DoxyCode}


\subsection*{Validation}

Method and options combinations are checked for validity at runtime to prevent creation of invalid query constructs. For example, a {\ttfamily distinct} query does not support specifying options like {\ttfamily hint} or field selection. In this case an error will be thrown so you can catch these mistakes in development.

\subsection*{Debug support}

Debug mode is provided through the use of the \href{https://github.com/visionmedia/debug}{\tt debug} module. To enable\+: \begin{DoxyVerb}DEBUG=mquery node yourprogram.js
\end{DoxyVerb}


Read the debug module documentation for more details.

\subsection*{General compatibility}

\paragraph*{Object\+Ids}

{\ttfamily mquery} clones query arguments before passing them to a {\ttfamily collection} method for execution. This prevents accidental side-\/affects to the objects you pass. To clone {\ttfamily Object\+Ids} we need to make some assumptions.

First, to check if an object is an {\ttfamily Object\+Id}, we check its constructors name. If it matches either {\ttfamily Object\+Id} or {\ttfamily Object\+ID} we clone it.

To clone {\ttfamily Object\+Ids}, we call its optional {\ttfamily clone} method. If a {\ttfamily clone} method does not exist, we fall back to calling {\ttfamily new obj.\+constructor(obj.\+id)}. We assume, for compatibility with the Node.\+js driver, that the {\ttfamily Object\+Id} instance has a public {\ttfamily id} property and that when creating an {\ttfamily Object\+Id} instance we can pass that {\ttfamily id} as an argument.

\paragraph*{Read Preferences}

{\ttfamily mquery} supports specifying \mbox{[}Read Preferences\mbox{]}() to control from which Mongo\+DB node your query will read. The Read Preferences spec also support specifying tags. To pass tags, some drivers (Node.\+js driver) require passing a special constructor that handles both the read preference and its tags. If you need to specify tags, pass an instance of your drivers Read\+Preference constructor or roll your own. {\ttfamily mquery} will store whatever you provide and pass later to your collection during execution.

\subsection*{Future goals}


\begin{DoxyItemize}
\item mongo shell compatibility
\item browser compatibility
\end{DoxyItemize}

\subsection*{Installation}

\begin{DoxyVerb}$ npm install mquery
\end{DoxyVerb}


\subsection*{License}

\href{https://github.com/aheckmann/mquery/blob/master/LICENSE}{\tt M\+IT} 