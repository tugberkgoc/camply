Mongoose now requires node.\+js $>$= 4.\+0.\+0 and Mongo\+DB $>$= 3.\+0.\+0. \href{https://www.mongodb.com/blog/post/mongodb-2-6-end-of-life}{\tt Mongo\+DB 2.\+6} and \href{https://github.com/nodejs/Release}{\tt Node.\+js $<$ 4} where both E\+O\+L-\/ed in 2016.

\subsubsection*{Query Middleware}

Query middleware is now compiled when you call {\ttfamily mongoose.\+model()} or {\ttfamily db.\+model()}. If you add query middleware after calling {\ttfamily mongoose.\+model()}, that middleware will {\bfseries not} get called.


\begin{DoxyCode}
const schema = new Schema(\{ name: String \});
const MyModel = mongoose.model('Test', schema);
schema.pre('find', () => \{ console.log('find!'); \});

MyModel.find().exec(function() \{
  // In mongoose 4.x, the above `.find()` will print "find!"
  // In mongoose 5.x, "find!" will **not** be printed.
  // Call `pre('find')` **before** calling `mongoose.model()` to make the middleware apply.
\});
\end{DoxyCode}


\subsubsection*{Promises and Callbacks for {\ttfamily mongoose.\+connect()}}

{\ttfamily mongoose.\+connect()} and {\ttfamily mongoose.\+disconnect()} now return a promise if no callback specified, or {\ttfamily null} otherwise. It does {\bfseries not} return the mongoose singleton.

\`{}\`{}{\ttfamily javascript // Worked in mongoose 4. Does $\ast$$\ast$not$\ast$$\ast$ work in mongoose 5,}mongoose.\+connect()\`{} // now returns a promise consistently. This is to avoid the horrible things // we\textquotesingle{}ve done to allow mongoose to be a thenable that resolves to itself. mongoose.\+connect(\textquotesingle{}mongodb\+://localhost\+:27017/test\textquotesingle{}).model(\textquotesingle{}Test\textquotesingle{}, new Schema(\{\}));

// Do this instead mongoose.\+connect(\textquotesingle{}mongodb\+://localhost\+:27017/test\textquotesingle{}); mongoose.\+model(\textquotesingle{}Test\textquotesingle{}, new Schema(\{\})); \`{}\`{}\`{}

\subsubsection*{Connection Logic and {\ttfamily use\+Mongo\+Client}}

The \href{http://mongoosejs.com/docs/4.x/docs/connections.html#use-mongo-client}{\tt {\ttfamily use\+Mongo\+Client} option} was removed in Mongoose 5, it is now always {\ttfamily true}. As a consequence, Mongoose 5 no longer supports several function signatures for {\ttfamily mongoose.\+connect()} that worked in Mongoose 4.\+x if the {\ttfamily use\+Mongo\+Client} option was off. Below are some examples of {\ttfamily mongoose.\+connect()} calls that do {\bfseries not} work in Mongoose 5.\+x.


\begin{DoxyItemize}
\item `mongoose.\+connect(\textquotesingle{}localhost', 27017);{\ttfamily  $\ast$}mongoose.\+connect(\textquotesingle{}localhost\textquotesingle{}, \textquotesingle{}mydb\textquotesingle{}, 27017);{\ttfamily  $\ast$}mongoose.\+connect(\textquotesingle{}mongodb\+://host1\+:27017,mongodb\+://host2\+:27017\textquotesingle{});\`{}
\end{DoxyItemize}

In Mongoose 5.\+x, the first parameter to {\ttfamily mongoose.\+connect()} and {\ttfamily mongoose.\+create\+Connection()}, if specified, {\bfseries must} be a \href{https://docs.mongodb.com/manual/reference/connection-string/}{\tt Mongo\+DB connection string}. The connection string and options are then passed down to \href{http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#.connect}{\tt the Mongo\+DB Node.\+js driver\textquotesingle{}s {\ttfamily Mongo\+Client.\+connect()} function}. Mongoose does not modify the connection string, although {\ttfamily mongoose.\+connect()} and {\ttfamily mongoose.\+create\+Connection()} support a \href{http://mongoosejs.com/docs/connections.html#options}{\tt few additional options in addition to the ones the Mongo\+DB driver supports}.

\subsubsection*{Setter Order}

Setters run in reverse order in 4.\+x\+:


\begin{DoxyCode}
const schema = new Schema(\{ name: String \});
schema.path('name').
  get(() => console.log('This will print 2nd')).
  get(() => console.log('This will print first'));
\end{DoxyCode}


In 5.\+x, setters run in the order they\textquotesingle{}re declared.


\begin{DoxyCode}
const schema = new Schema(\{ name: String \});
schema.path('name').
  get(() => console.log('This will print first')).
  get(() => console.log('This will print 2nd'));
\end{DoxyCode}


\subsubsection*{Checking if a path is populated}

Mongoose 5.\+1.\+0 introduced an {\ttfamily \+\_\+id} getter to Object\+Ids that lets you get an Object\+Id regardless of whether a path is populated.


\begin{DoxyCode}
const blogPostSchema = new Schema(\{
  title: String,
  author: \{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Author'
  \}
\});
const BlogPost = mongoose.model('BlogPost', blogPostSchema);

await BlogPost.create(\{ title: 'test', author: author.\_id \});
const blogPost = await BlogPost.findOne();

console.log(blogPost.author); // '5b207f84e8061d1d2711b421'
// New in Mongoose 5.1.0: this will print '5b207f84e8061d1d2711b421' as well
console.log(blogPost.author.\_id);

await blogPost.populate('author');
console.log(blogPost.author.\_id); '5b207f84e8061d1d2711b421'
\end{DoxyCode}


As a consequence, checking whether {\ttfamily blog\+Post.\+author.\+\_\+id} is \href{https://github.com/Automattic/mongoose/issues/6415#issuecomment-388579185}{\tt no longer viable as a way to check whether {\ttfamily author} is populated}. Use `blog\+Post.\+populated(\textquotesingle{}author') != null{\ttfamily or}blog\+Post.\+author instanceof mongoose.\+Types.\+Object\+Id$<$tt$>$to check whetherauthor\`{} is populated instead.

Note that you can call `mongoose.\+set(\textquotesingle{}object\+Id\+Getter', false)\`{} to change this behavior.

\subsubsection*{Return Values for {\ttfamily remove()} and {\ttfamily delete\+X()}}

{\ttfamily delete\+One()}, {\ttfamily delete\+Many()}, and {\ttfamily remove()} now resolve to the result object rather than the full \href{http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~writeOpCallback}{\tt driver {\ttfamily Write\+Op\+Result} object}.


\begin{DoxyCode}
// In 4.x, this is how you got the number of documents deleted
MyModel.deleteMany().then(res => console.log(res.result.n));
// In 5.x this is how you get the number of documents deleted
MyModel.deleteMany().then(res => res.n);
\end{DoxyCode}


\subsubsection*{Aggregation Cursors}

The {\ttfamily use\+Mongoose\+Agg\+Cursor} option from 4.\+x is now always on. This is the new syntax for aggregation cursors in mongoose 5\+:

\`{}\`{}{\ttfamily javascript // When you call}.cursor(){\ttfamily ,}.exec()\`{} will now return a mongoose aggregation // cursor. const cursor = My\+Model.\+aggregate(\mbox{[}\{ \$match\+: \{ name\+: \textquotesingle{}Val\textquotesingle{} \} \}\mbox{]}).cursor().exec(); // No need to {\ttfamily await} on the cursor or wait for a promise to resolve cursor.\+each\+Async(doc =$>$ console.\+log(doc));

// Can also pass options to {\ttfamily cursor()} const cursor\+With\+Options = My\+Model. aggregate(\mbox{[}\{ \$match\+: \{ name\+: \textquotesingle{}Val\textquotesingle{} \} \}\mbox{]}). cursor(\{ batch\+Size\+: 10 \}). exec(); 
\begin{DoxyCode}
### geoNear

`Model.geoNear()` has been removed because the [MongoDB driver no longer supports
       it](https://github.com/mongodb/node-mongodb-native/blob/master/CHANGES\_3.0.0.md#geonear-command-helper)

### Required URI encoding of connection strings

Due to changes in the MongoDB driver, connection strings must be URI encoded.

If they are not, connections may fail with an illegal character message.

#### Passwords which contain certain characters

See a [full list of affected
       characters](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).

If your app is used by a lot of different connection strings, it's possible
that your test cases will pass, but production passwords will fail. Encode all your connection
strings to be safe.

If you want to continue to use unencoded connection strings, the easiest fix is to use
the `mongodb-uri` module to parse the connection strings, and then produce the properly encoded
versions. You can use a function like this:

```javascript
const uriFormat = require('mongodb-uri')
function encodeMongoURI (urlString) \{
    if (urlString) \{
      let parsed = uriFormat.parse(urlString)
      urlString = uriFormat.format(parsed);
    \}
    return urlString;
  \}
\}

// Your un-encoded string.
const mongodbConnectString = "mongodb://...";
mongoose.connect(encodeMongoURI(mongodbConnectString))
\end{DoxyCode}


The function above is safe to use whether the existing string is already encoded or not.

\paragraph*{Domain sockets}

Domain sockets must be U\+RI encoded. For example\+:


\begin{DoxyCode}
// Works in mongoose 4. Does **not** work in mongoose 5 because of more
// stringent URI parsing.
const host = '/tmp/mongodb-27017.sock';
mongoose.createConnection(`mongodb://aaron:psw@$\{host\}/fake`);

// Do this instead
const host = encodeURIComponent('/tmp/mongodb-27017.sock');
mongoose.createConnection(`mongodb://aaron:psw@$\{host\}/fake`);
\end{DoxyCode}


\subsubsection*{{\ttfamily to\+Object()} Options}

The {\ttfamily options} parameter to {\ttfamily to\+Object()} and {\ttfamily to\+J\+S\+O\+N()} merge defaults rather than overwriting them.

\`{}\`{}{\ttfamily javascript // Note the}to\+Object\`{} option below const schema = new Schema(\{ name\+: String \}, \{ to\+Object\+: \{ virtuals\+: true \} \}); schema.\+virtual(\textquotesingle{}answer\textquotesingle{}).get(() =$>$ 42); const My\+Model = db.\+model(\textquotesingle{}My\+Model\textquotesingle{}, schema);

const doc = new My\+Model(\{ name\+: \textquotesingle{}test\textquotesingle{} \}); // In mongoose 4.\+x this prints \char`\"{}undefined\char`\"{}, because {\ttfamily \{ minimize\+: false \}} // overwrites the entire schema-\/defined options object. // In mongoose 5.\+x this prints \char`\"{}42\char`\"{}, because {\ttfamily \{ minimize\+: false \}} gets // merged with the schema-\/defined options. console.\+log(doc.\+to\+J\+S\+ON(\{ minimize\+: false \}).answer); 
\begin{DoxyCode}
### Aggregate Parameters

`aggregate()` no longer accepts a spread, you **must** pass your aggregation pipeline as an array. The
       below code worked in 4.x:

```javascript
MyModel.aggregate(\{ $match: \{ isDeleted: false \} \}, \{ $skip: 10 \}).exec(cb);
\end{DoxyCode}


The above code does {\bfseries not} work in 5.\+x, you {\bfseries must} wrap the {\ttfamily \$match} and {\ttfamily \$skip} stages in an array.


\begin{DoxyCode}
MyModel.aggregate([\{ $match: \{ isDeleted: false \} \}, \{ $skip: 10 \}]).exec(cb);
\end{DoxyCode}


\subsubsection*{Boolean Casting}

By default, mongoose 4 would coerce any value to a boolean without error.

\`{}\`{}{\ttfamily javascript // Fine in mongoose 4, would save a doc with}bool\+Field = true` const My\+Model = mongoose.\+model(\textquotesingle{}Test', new Schema(\{ bool\+Field\+: Boolean \}));

My\+Model.\+create(\{ bool\+Field\+: \textquotesingle{}not a boolean\textquotesingle{} \}); \`{}\`{}\`{}

Mongoose 5 only casts the following values to {\ttfamily true}\+:


\begin{DoxyItemize}
\item {\ttfamily true}
\item `\textquotesingle{}true'{\ttfamily  $\ast$}1{\ttfamily  $\ast$}\textquotesingle{}1\textquotesingle{}{\ttfamily  $\ast$}\textquotesingle{}yes\textquotesingle{}\`{}
\end{DoxyItemize}

And the following values to {\ttfamily false}\+:


\begin{DoxyItemize}
\item {\ttfamily false}
\item `\textquotesingle{}false'{\ttfamily  $\ast$}0{\ttfamily  $\ast$}\textquotesingle{}0\textquotesingle{}{\ttfamily  $\ast$}\textquotesingle{}no\textquotesingle{}\`{}
\end{DoxyItemize}

All other values will cause a {\ttfamily Cast\+Error} \subsubsection*{Query Casting}

Casting for {\ttfamily update()}, {\ttfamily update\+One()}, {\ttfamily update\+Many()}, {\ttfamily replace\+One()}, {\ttfamily remove()}, {\ttfamily delete\+One()}, and {\ttfamily delete\+Many()} doesn\textquotesingle{}t happen until {\ttfamily exec()}. This makes it easier for hooks and custom query helpers to modify data, because mongoose won\textquotesingle{}t restructure the data you passed in until after your hooks and query helpers have ran. It also makes it possible to set the {\ttfamily overwrite} option {\itshape after} passing in an update.

\`{}\`{}{\ttfamily javascript // In mongoose 4.\+x, this becomes}\{ \$set\+: \{ name\+: \textquotesingle{}Baz\textquotesingle{} \} \}{\ttfamily despite the}overwrite\`{} // In mongoose 5.\+x, this overwrite is respected and the first document with // `name = \textquotesingle{}Bar'{\ttfamily will be replaced with}\{ name\+: \textquotesingle{}Baz\textquotesingle{} \}` User.\+where(\{ name\+: \textquotesingle{}Bar' \}).update(\{ name\+: \textquotesingle{}Baz\textquotesingle{} \}).set\+Options(\{ overwrite\+: true \}); \`{}\`{}\`{}

\subsubsection*{Post Save Hooks Get Flow Control}

Post hooks now get flow control, which means async post save hooks and child document post save hooks execute {\bfseries before} your {\ttfamily save()} callback.

\`{}\`{}\`{}javsscript const Child\+Model\+Schema = new mongoose.\+Schema(\{ text\+: \{ type\+: String \} \}); Child\+Model\+Schema.\+post(\textquotesingle{}save\textquotesingle{}, function(doc) \{ // In mongoose 5.\+x this will print {\bfseries before} the {\ttfamily console.\+log()} // in the {\ttfamily save()} callback. In mongoose 4.\+x this was reversed. console.\+log(\textquotesingle{}Child post save\textquotesingle{}); \}); const Parent\+Model\+Schema = new mongoose.\+Schema(\{ children\+: \mbox{[}Child\+Model\+Schema\mbox{]} \});

const Model = mongoose.\+model(\textquotesingle{}Parent\textquotesingle{}, Parent\+Model\+Schema); const m = new Model(\{ children\+: \mbox{[}\{ text\+: \textquotesingle{}test\textquotesingle{} \}\mbox{]} \}); m.\+save(function() \{ // In mongoose 5.\+xm this prints {\bfseries after} the \char`\"{}\+Child post save\char`\"{} message. console.\+log(\textquotesingle{}Save callback\textquotesingle{}); \}); \`{}\`{}\`{}

\subsubsection*{The {\ttfamily \$push\+All} Operator}

{\ttfamily \$push\+All} is no longer supported and no longer used internally for {\ttfamily save()}, since it has been \href{https://docs.mongodb.com/manual/reference/operator/update/pushAll/}{\tt deprecated since Mongo\+DB 2.\+4}. Use {\ttfamily \$push} with {\ttfamily \$each} instead.

\subsubsection*{Always Use Forward Key Order}

The {\ttfamily retain\+Key\+Order} option was removed, mongoose will now always retain the same key position when cloning objects. If you have queries or indexes that rely on reverse key order, you will have to change them.

\subsubsection*{Run setters on queries}

Setters now run on queries by default, and the old {\ttfamily run\+Setters\+On\+Query} option has been removed.

\`{}\`{}\`{}javascript const schema = new Schema(\{ email\+: \{ type\+: String, lowercase\+: true \} \}); const Model = mongoose.\+model(\textquotesingle{}Test\textquotesingle{}, schema); Model.\+find(\{ email\+: \textquotesingle{}\href{mailto:FOO@BAR.BAZ}{\tt F\+O\+O@\+B\+A\+R.\+B\+AZ}\textquotesingle{} \}); // Converted to `find(\{ email\+: \textquotesingle{}\href{mailto:foo@bar.baz}{\tt foo@bar.\+baz}' \}){\ttfamily  }\`{}\`{}

\subsubsection*{Pre-\/compiled Browser Bundle}

We no longer have a pre-\/compiled version of mongoose for the browser. If you want to use mongoose schemas in the browser, you need to build your own bundle with browserify/webpack.

\subsubsection*{Save Errors}

The {\ttfamily save\+Error\+If\+Not\+Found} option was removed, mongoose will now always error out from {\ttfamily save()} if the underlying document was not found

\subsubsection*{Init hook signatures}

{\ttfamily init} hooks are now fully synchronous and do not receive {\ttfamily next()} as a parameter.

{\ttfamily Document.\+prototype.\+init()} no longer takes a callback as a parameter. It was always synchronous, just had a callback for legacy reasons.

\subsubsection*{{\ttfamily num\+Affected} and {\ttfamily save()}}

{\ttfamily doc.\+save()} no longer passes {\ttfamily num\+Affected} as a 3rd param to its callback.

\subsubsection*{{\ttfamily remove()} and debouncing}

{\ttfamily doc.\+remove()} no longer debounces

\subsubsection*{{\ttfamily get\+Promise\+Constructor()}}

{\ttfamily get\+Promise\+Constructor()} is gone, just use {\ttfamily mongoose.\+Promise}.

\subsubsection*{Passing Parameters from Pre Hooks}

You cannot pass parameters to the next pre middleware in the chain using {\ttfamily next()} in mongoose 5.\+x. In mongoose 4, `next(\textquotesingle{}Test')` in pre middleware would call the next middleware with \textquotesingle{}Test' as a parameter. Mongoose 5.\+x has removed support for this.

\subsubsection*{{\ttfamily required} validator for arrays}

In mongoose 5 the {\ttfamily required} validator only verifies if the value is an array. That is, it will {\bfseries not} fail for {\itshape empty} arrays as it would in mongoose 4.

\subsubsection*{debug output defaults to stdout instead of stderr}

In mongoose 5 the default debug function uses {\ttfamily console.\+info()} to display messages instead of {\ttfamily console.\+error()}.

\subsubsection*{Overwriting filter properties}

In Mongoose 4.\+x, overwriting a filter property that\textquotesingle{}s a primitive with one that is an object would silently fail. For example, the below code would ignore the {\ttfamily where()} and be equivalent to `Sport.\+find(\{ name\+: \textquotesingle{}baseball' \})\`{}


\begin{DoxyCode}
Sport.find(\{ name: 'baseball' \}).where(\{name: \{$ne: 'softball'\}\});
\end{DoxyCode}


In Mongoose 5.\+x, the above code will correctly overwrite `\textquotesingle{}baseball'{\ttfamily with}\{ \$ne\+: \textquotesingle{}softball\textquotesingle{} \}\`{}

\subsubsection*{{\ttfamily bulk\+Write()} results}

Mongoose 5.\+x uses version 3.\+x of the \href{http://npmjs.com/package/mongodb}{\tt Mongo\+DB Node.\+js driver}. Mongo\+DB driver 3.\+x changed the format of the result of \href{http://localhost:8088/docs/api.html#model_Model.bulkWrite}{\tt {\ttfamily bulk\+Write()} calls} so there is no longer a top-\/level {\ttfamily n\+Inserted}, {\ttfamily n\+Modified}, etc. property. The new result object structure is \href{http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#~BulkWriteOpResult}{\tt described here}.


\begin{DoxyCode}
const Model = mongoose.model('Test', new Schema(\{ name: String \}));

const res = await Model.bulkWrite([\{ insertOne: \{ document: \{ name: 'test' \} \} \}]);

console.log(res);
\end{DoxyCode}


In Mongoose 4.\+x, the above will print\+:


\begin{DoxyCode}
BulkWriteResult \{
  ok: [Getter],
  nInserted: [Getter],
  nUpserted: [Getter],
  nMatched: [Getter],
  nModified: [Getter],
  nRemoved: [Getter],
  getInsertedIds: [Function],
  getUpsertedIds: [Function],
  getUpsertedIdAt: [Function],
  getRawResponse: [Function],
  hasWriteErrors: [Function],
  getWriteErrorCount: [Function],
  getWriteErrorAt: [Function],
  getWriteErrors: [Function],
  getLastOp: [Function],
  getWriteConcernError: [Function],
  toJSON: [Function],
  toString: [Function],
  isOk: [Function],
  insertedCount: 1,
  matchedCount: 0,
  modifiedCount: 0,
  deletedCount: 0,
  upsertedCount: 0,
  upsertedIds: \{\},
  insertedIds: \{ '0': 5be9a3101638a066702a0d38 \},
  n: 1 \}
\end{DoxyCode}


In Mongoose 5.\+x, the script will print\+:


\begin{DoxyCode}
BulkWriteResult \{
  result: 
   \{ ok: 1,
     writeErrors: [],
     writeConcernErrors: [],
     insertedIds: [ [Object] ],
     nInserted: 1,
     nUpserted: 0,
     nMatched: 0,
     nModified: 0,
     nRemoved: 0,
     upserted: [],
     lastOp: \{ ts: [Object], t: 1 \} \},
  insertedCount: 1,
  matchedCount: 0,
  modifiedCount: 0,
  deletedCount: 0,
  upsertedCount: 0,
  upsertedIds: \{\},
  insertedIds: \{ '0': 5be9a1c87decfc6443dd9f18 \},
  n: 1 \}
\end{DoxyCode}
 