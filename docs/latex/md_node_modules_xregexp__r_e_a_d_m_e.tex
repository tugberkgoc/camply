X\+Reg\+Exp provides augmented, extensible, cross-\/browser Java\+Script regular expressions. You get new syntax and flags beyond what browsers support natively, along with a collection of utils to make your client-\/side grepping and parsing easier. X\+Reg\+Exp also frees you from worrying about pesky inconsistencies in cross-\/browser regex handling and the dubious {\ttfamily last\+Index} property.

X\+Reg\+Exp supports all native E\+S5 regular expression syntax. It\textquotesingle{}s about 3.\+5 KB when minified and gzipped. It works with Internet Explorer 5.\+5+, Firefox 1.\+5+, Chrome, Safari 3+, and Opera 9.\+5+.

\subsection*{Performance}

X\+Reg\+Exp regular expressions compile to native Reg\+Exp objects, thus there is no performance difference when using X\+Reg\+Exp objects with native methods. There is a small performance cost when {\itshape compiling} X\+Reg\+Exps. If you want, however, you can use {\ttfamily X\+Reg\+Exp.\+cache} to avoid ever incurring the compilation cost for a given pattern more than once. Doing so can even lead to X\+Reg\+Exp being faster than native regexes in synthetic tests that repeatedly compile the same regex.

\subsection*{Usage examples}


\begin{DoxyCode}
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp('(?<year>  [0-9]\{4\}) -?  # year  \(\backslash\)n\(\backslash\)
                    (?<month> [0-9]\{2\}) -?  # month \(\backslash\)n\(\backslash\)
                    (?<day>   [0-9]\{2\})     # day   ', 'x');

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.exec('2012-02-22', date);
match.day; // -> '22'

// It also includes optional pos and sticky arguments
var pos = 3, result = [];
while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\(\backslash\)d+)>/, pos, 'sticky')) \{
    result.push(match[1]);
    pos = match.index + match[0].length;
\} // result -> ['2', '3', '4']

// XRegExp.replace allows named backreferences in replacements
XRegExp.replace('2012-02-22', date, '$\{month\}/$\{day\}/$\{year\}'); // -> '02/22/2012'
XRegExp.replace('2012-02-22', date, function (match) \{
    return match.month + '/' + match.day + '/' + match.year;
\}); // -> '02/22/2012'

// In fact, all XRegExps are RegExps and work perfectly with native methods
date.test('2012-02-22'); // -> true

// The *only* caveat is that named captures must be referred to using numbered backreferences
'2012-02-22'.replace(date, '$2/$3/$1'); // -> '02/22/2012'

// If you want, you can extend native methods so you don't have to worry about this
// Doing so also fixes numerous browser bugs in the native methods
XRegExp.install('natives');
'2012-02-22'.replace(date, '$\{month\}/$\{day\}/$\{year\}'); // -> '02/22/2012'
'2012-02-22'.replace(date, function (match) \{
    return match.month + '/' + match.day + '/' + match.year;
\}); // -> '02/22/2012'
date.exec('2012-02-22').day; // -> '22'

// Extract every other digit from a string using XRegExp.forEach
XRegExp.forEach('1a2345', /\(\backslash\)d/, function (match, i) \{
    if (i % 2) this.push(+match[0]);
\}, []); // -> [2, 4]

// Get numbers within <b> tags using XRegExp.matchChain
XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
    XRegExp('(?is)<b>.*?</b>'),
    /\(\backslash\)d+/
]); // -> ['2', '4', '56']

// You can also pass forward and return specific backreferences
var html = '<a href="http://xregexp.com/">XRegExp</a>\(\backslash\)
            <a href="http://www.google.com/">Google</a>';
XRegExp.matchChain(html, [
    \{regex: /<a href="([^"]+)">/i, backref: 1\},
    \{regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'\}
]); // -> ['xregexp.com', 'www.google.com']

// XRegExp.union safely merges strings and regexes into a single pattern
XRegExp.union(['a+b*c', /(dogs)\(\backslash\)1/, /(cats)\(\backslash\)1/], 'i');
// -> /a\(\backslash\)+b\(\backslash\)*c|(dogs)\(\backslash\)1|(cats)\(\backslash\)2/i
\end{DoxyCode}


These examples should give you the flavor of what\textquotesingle{}s possible, but X\+Reg\+Exp has more syntax, flags, utils, options, and browser fixes that aren\textquotesingle{}t shown here. You can even augment X\+Reg\+Exp\textquotesingle{}s regular expression syntax with addons (see below) or write your own. See \href{http://xregexp.com/}{\tt xregexp.\+com} for more details.

\subsection*{Addons}

In browsers, you can either load addons individually, or bundle all addons together with X\+Reg\+Exp by loading {\ttfamily xregexp-\/all.\+js}. X\+Reg\+Exp\textquotesingle{}s \href{http://npmjs.org/}{\tt npm} package uses {\ttfamily xregexp-\/all.\+js}, which means that the addons are always available when X\+Reg\+Exp is installed on the server using npm.

\subsubsection*{X\+Reg\+Exp Unicode Base}

In browsers, first include the Unicode Base script\+:


\begin{DoxyCode}
<script src="xregexp.js"></script>
<script src="addons/unicode/unicode-base.js"></script>
\end{DoxyCode}


Then you can do this\+:


\begin{DoxyCode}
var unicodeWord = XRegExp('^\(\backslash\)\(\backslash\)p\{L\}+$');
unicodeWord.test('Русский'); // -> true
unicodeWord.test('日本語'); // -> true
unicodeWord.test('العربية'); // -> true
\end{DoxyCode}


The base script adds {\ttfamily \textbackslash{}p\{Letter\}} and its alias {\ttfamily \textbackslash{}p\{L\}}, but other Unicode categories, scripts, blocks, and properties require addon packages. Try these next examples after additionally including {\ttfamily unicode-\/scripts.\+js}\+:


\begin{DoxyCode}
XRegExp('^\(\backslash\)\(\backslash\)p\{Hiragana\}+$').test('ひらがな'); // -> true
XRegExp('^[\(\backslash\)\(\backslash\)p\{Latin\}\(\backslash\)\(\backslash\)p\{Common\}]+$').test('Über Café.'); // -> true
\end{DoxyCode}


X\+Reg\+Exp uses the Unicode 6.\+1 Basic Multilingual Plane.

\subsubsection*{X\+Reg\+Exp.\+build}

In browsers, first include the script\+:


\begin{DoxyCode}
<script src="xregexp.js"></script>
<script src="addons/build.js"></script>
\end{DoxyCode}


You can then build regular expressions using named subpatterns, for readability and pattern reuse\+:


\begin{DoxyCode}
var time = XRegExp.build('(?x)^ \{\{hours\}\} (\{\{minutes\}\}) $', \{
    hours: XRegExp.build('\{\{h12\}\} : | \{\{h24\}\}', \{
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    \}, 'x'),
    minutes: /^[0-5][0-9]$/
\});

time.test('10:59'); // -> true
XRegExp.exec('10:59', time).minutes; // -> '59'
\end{DoxyCode}


Named subpatterns can be provided as strings or regex objects. A leading {\ttfamily $^\wedge$} and trailing unescaped {\ttfamily \$} are stripped from subpatterns if both are present, which allows embedding independently useful anchored patterns. {\ttfamily \{\{…\}\}} tokens can be quantified as a single unit. Backreferences in the outer pattern and provided subpatterns are automatically renumbered to work correctly within the larger combined pattern. The syntax {\ttfamily (\{\{name\}\})} works as shorthand for named capture via {\ttfamily (?$<$name$>$\{\{name\}\})}. Named subpatterns cannot be embedded within character classes.

See also\+: {\itshape \href{http://blog.stevenlevithan.com/archives/grammatical-patterns-xregexp-build}{\tt Creating Grammatical Regexes Using X\+Reg\+Exp.\+build}}.

\subsubsection*{X\+Reg\+Exp.\+match\+Recursive}

In browsers, first include the script\+:


\begin{DoxyCode}
<script src="xregexp.js"></script>
<script src="addons/matchrecursive.js"></script>
\end{DoxyCode}


You can then match recursive constructs using X\+Reg\+Exp pattern strings as left and right delimiters\+:


\begin{DoxyCode}
var str = '(t((e))s)t()(ing)';
XRegExp.matchRecursive(str, '\(\backslash\)\(\backslash\)(', '\(\backslash\)\(\backslash\))', 'g');
// -> ['t((e))s', '', 'ing']

// Extended information mode with valueNames
str = 'Here is <div> <div>an</div></div> example';
XRegExp.matchRecursive(str, '<div\(\backslash\)\(\backslash\)s*>', '</div>', 'gi', \{
    valueNames: ['between', 'left', 'match', 'right']
\});
/* -> [
\{name: 'between', value: 'Here is ',       start: 0,  end: 8\},
\{name: 'left',    value: '<div>',          start: 8,  end: 13\},
\{name: 'match',   value: ' <div>an</div>', start: 13, end: 27\},
\{name: 'right',   value: '</div>',         start: 27, end: 33\},
\{name: 'between', value: ' example',       start: 33, end: 41\}
] */

// Omitting unneeded parts with null valueNames, and using escapeChar
str = '...\{1\}\(\backslash\)\(\backslash\)\{\{function(x,y)\{return y+x;\}\}';
XRegExp.matchRecursive(str, '\{', '\}', 'g', \{
    valueNames: ['literal', null, 'value', null],
    escapeChar: '\(\backslash\)\(\backslash\)'
\});
/* -> [
\{name: 'literal', value: '...', start: 0, end: 3\},
\{name: 'value',   value: '1',   start: 4, end: 5\},
\{name: 'literal', value: '\(\backslash\)\(\backslash\)\{', start: 6, end: 8\},
\{name: 'value',   value: 'function(x,y)\{return y+x;\}', start: 9, end: 35\}
] */

// Sticky mode via flag y
str = '<1><<<2>>><3>4<5>';
XRegExp.matchRecursive(str, '<', '>', 'gy');
// -> ['1', '<<2>>', '3']
\end{DoxyCode}


{\ttfamily X\+Reg\+Exp.\+match\+Recursive} throws an error if it sees an unbalanced delimiter in the target string.

\subsubsection*{X\+Reg\+Exp Prototype Methods}

In browsers, first include the script\+:


\begin{DoxyCode}
<script src="xregexp.js"></script>
<script src="addons/prototypes.js"></script>
\end{DoxyCode}


New X\+Reg\+Exp regexes then gain a collection of useful methods\+: {\ttfamily apply}, {\ttfamily call}, {\ttfamily for\+Each}, {\ttfamily globalize}, {\ttfamily xexec}, and {\ttfamily xtest}.


\begin{DoxyCode}
// To demonstrate the call method, let's first create the function we'll be using...
function filter(array, fn) \{
    var res = [];
    array.forEach(function (el) \{if (fn.call(null, el)) res.push(el);\});
    return res;
\}
// Now we can filter arrays using functions and regexes
filter(['a', 'ba', 'ab', 'b'], XRegExp('^a')); // -> ['a', 'ab']
\end{DoxyCode}


Native {\ttfamily Reg\+Exp} objects copied by {\ttfamily X\+Reg\+Exp} are augmented with any {\ttfamily X\+Reg\+Exp.\+prototype} methods. The following lines therefore work equivalently\+:


\begin{DoxyCode}
XRegExp('[a-z]', 'ig').xexec('abc');
XRegExp(/[a-z]/ig).xexec('abc');
XRegExp.globalize(/[a-z]/i).xexec('abc');
\end{DoxyCode}


\subsection*{Installation and usage}

In browsers\+:


\begin{DoxyCode}
<script src="xregexp-min.js"></script>
\end{DoxyCode}


Or, to bundle X\+Reg\+Exp with all of its addons\+:


\begin{DoxyCode}
<script src="xregexp-all-min.js"></script>
\end{DoxyCode}


Using \href{http://npmjs.org/}{\tt npm}\+:


\begin{DoxyCode}
npm install xregexp
\end{DoxyCode}


In \href{http://nodejs.org/}{\tt Node.\+js} and \href{http://wiki.commonjs.org/wiki/Modules}{\tt Common\+JS module} loaders\+:


\begin{DoxyCode}
var XRegExp = require('xregexp').XRegExp;
\end{DoxyCode}


\subsubsection*{Running tests on the server with npm}


\begin{DoxyCode}
npm install -g qunit  # needed to run the tests
npm test  # in the xregexp root
\end{DoxyCode}


If X\+Reg\+Exp was not installed using npm, just open {\ttfamily tests/index.\+html} in your browser.

\subsection*{\&c}

{\bfseries Lookbehind\+:} A \href{https://gist.github.com/2387872}{\tt collection of short functions} is available that makes it easy to simulate infinite-\/length leading lookbehind.

\subsection*{Changelog}


\begin{DoxyItemize}
\item Releases\+: \href{http://xregexp.com/history/}{\tt Version history}.
\item Upcoming\+: \href{https://github.com/slevithan/XRegExp/issues/milestones}{\tt Milestones}, \href{https://github.com/slevithan/XRegExp/wiki/Roadmap}{\tt Roadmap}.
\end{DoxyItemize}

\subsection*{About}

X\+Reg\+Exp and addons copyright 2007-\/2012 by \href{http://stevenlevithan.com/}{\tt Steven Levithan}.

Tools\+: Unicode range generators by \href{http://mathiasbynens.be/}{\tt Mathias Bynens}. Source file concatenator by \href{http://twitter.com/walling}{\tt Bjarke Walling}.

Prior art\+: {\ttfamily X\+Reg\+Exp.\+build} inspired by \href{http://lea.verou.me/}{\tt Lea Verou}\textquotesingle{}s \href{http://lea.verou.me/2011/03/create-complex-regexps-more-easily/}{\tt Reg\+Exp.\+create}. {\ttfamily X\+Reg\+Exp.\+union} inspired by \href{http://www.ruby-lang.org/}{\tt Ruby}. X\+Reg\+Exp\textquotesingle{}s syntax extensions come from Perl, .N\+ET, etc.

All code released under the \href{http://mit-license.org/}{\tt M\+IT License}.

Fork me to show support, fix, and extend. 