\href{https://travis-ci.org/rvagg/bl}{\tt }

{\bfseries A Node.\+js Buffer list collector, reader and streamer thingy.}

\href{https://nodei.co/npm/bl/}{\tt } \href{https://nodei.co/npm/bl/}{\tt }

{\bfseries bl} is a storage object for collections of Node Buffers, exposing them with the main Buffer readable A\+PI. Also works as a duplex stream so you can collect buffers from a stream that emits them and emit buffers to a stream that consumes them!

The original buffers are kept intact and copies are only done as necessary. Any reads that require the use of a single original buffer will return a slice of that buffer only (which references the same memory as the original buffer). Reads that span buffers perform concatenation as required and return the results transparently.


\begin{DoxyCode}
const BufferList = require('bl')

var bl = new BufferList()
bl.append(new Buffer('abcd'))
bl.append(new Buffer('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(new Buffer('j'))
bl.append(new Buffer([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\(\backslash\)u0003\(\backslash\)u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
\end{DoxyCode}


Give it a callback in the constructor and use it just like {\bfseries \href{https://github.com/maxogden/node-concat-stream}{\tt concat-\/stream}}\+:


\begin{DoxyCode}
const bl = require('bl')
    , fs = require('fs')

fs.createReadStream('README.md')
  .pipe(bl(function (err, data) \{ // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  \}))
\end{DoxyCode}


Note that when you use the {\itshape callback} method like this, the resulting {\ttfamily data} parameter is a concatenation of all {\ttfamily Buffer} objects in the list. If you want to avoid the overhead of this concatenation (in cases of extreme performance consciousness), then avoid the {\itshape callback} method and just listen to `\textquotesingle{}end'\`{} instead, like a standard Stream.

Or to fetch a U\+RL using \href{https://github.com/substack/hyperquest}{\tt hyperquest} (should work with \href{http://github.com/mikeal/request}{\tt request} and even plain Node http too!)\+: 
\begin{DoxyCode}
const hyperquest = require('hyperquest')
    , bl         = require('bl')
    , url        = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(bl(function (err, data) \{
  console.log(data.toString())
\}))
\end{DoxyCode}


Or, use it as a readable stream to recompose a list of Buffers to an output source\+:


\begin{DoxyCode}
const BufferList = require('bl')
    , fs         = require('fs')

var bl = new BufferList()
bl.append(new Buffer('abcd'))
bl.append(new Buffer('efg'))
bl.append(new Buffer('hi'))
bl.append(new Buffer('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
\end{DoxyCode}


\subsection*{A\+PI}


\begin{DoxyItemize}
\item \href{#ctor}{\tt {\ttfamily {\bfseries new Buffer\+List(\mbox{[} callback \mbox{]})}}}
\item \href{#length}{\tt {\ttfamily bl.{\bfseries length}}}
\item \href{#append}{\tt {\ttfamily bl.{\bfseries append(buffer)}}}
\item \href{#get}{\tt {\ttfamily bl.{\bfseries get(index)}}}
\item \href{#slice}{\tt {\ttfamily bl.{\bfseries slice(\mbox{[} start\mbox{[}, end \mbox{]} \mbox{]})}}}
\item \href{#shallowSlice}{\tt {\ttfamily bl.{\bfseries shallow\+Slice(\mbox{[} start\mbox{[}, end \mbox{]} \mbox{]})}}}
\item \href{#copy}{\tt {\ttfamily bl.{\bfseries copy(dest, \mbox{[} dest\+Start, \mbox{[} src\+Start \mbox{[}, src\+End \mbox{]} \mbox{]} \mbox{]})}}}
\item \href{#duplicate}{\tt {\ttfamily bl.{\bfseries duplicate()}}}
\item \href{#consume}{\tt {\ttfamily bl.{\bfseries consume(bytes)}}}
\item \href{#toString}{\tt {\ttfamily bl.{\bfseries to\+String(\mbox{[}encoding, \mbox{[} start, \mbox{[} end \mbox{]}\mbox{]}\mbox{]})}}}
\item \href{#readXX}{\tt {\ttfamily bl.{\bfseries read\+Double\+B\+E()}}, {\ttfamily bl.{\bfseries read\+Double\+L\+E()}}, {\ttfamily bl.{\bfseries read\+Float\+B\+E()}}, {\ttfamily bl.{\bfseries read\+Float\+L\+E()}}, {\ttfamily bl.{\bfseries read\+Int32\+B\+E()}}, {\ttfamily bl.{\bfseries read\+Int32\+L\+E()}}, {\ttfamily bl.{\bfseries read\+U\+Int32\+B\+E()}}, {\ttfamily bl.{\bfseries read\+U\+Int32\+L\+E()}}, {\ttfamily bl.{\bfseries read\+Int16\+B\+E()}}, {\ttfamily bl.{\bfseries read\+Int16\+L\+E()}}, {\ttfamily bl.{\bfseries read\+U\+Int16\+B\+E()}}, {\ttfamily bl.{\bfseries read\+U\+Int16\+L\+E()}}, {\ttfamily bl.{\bfseries read\+Int8()}}, {\ttfamily bl.{\bfseries read\+U\+Int8()}}}
\item \href{#streams}{\tt Streams} 

 \label{_ctor}%
 \subsubsection*{new Buffer\+List(\mbox{[} callback $\vert$ Buffer $\vert$ Buffer array $\vert$ Buffer\+List $\vert$ Buffer\+List array $\vert$ String \mbox{]})}
\end{DoxyItemize}

The constructor takes an optional callback, if supplied, the callback will be called with an error argument followed by a reference to the {\bfseries bl} instance, when {\ttfamily bl.\+end()} is called (i.\+e. from a piped stream). This is a convenient method of collecting the entire contents of a stream, particularly when the stream is {\itshape chunky}, such as a network stream.

Normally, no arguments are required for the constructor, but you can initialise the list by passing in a single {\ttfamily Buffer} object or an array of {\ttfamily Buffer} object.

{\ttfamily new} is not strictly required, if you don\textquotesingle{}t instantiate a new object, it will be done automatically for you so you can create a new instance simply with\+:


\begin{DoxyCode}
var bl = require('bl')
var myinstance = bl()

// equivalent to:

var BufferList = require('bl')
var myinstance = new BufferList()
\end{DoxyCode}
 

 \label{_length}%
 \subsubsection*{bl.\+length}

Get the length of the list in bytes. This is the sum of the lengths of all of the buffers contained in the list, minus any initial offset for a semi-\/consumed buffer at the beginning. Should accurately represent the total number of bytes that can be read from the list. 

 \label{_append}%
 \subsubsection*{bl.\+append(Buffer $\vert$ Buffer array $\vert$ Buffer\+List $\vert$ Buffer\+List array $\vert$ String)}

{\ttfamily append(buffer)} adds an additional buffer or Buffer\+List to the internal list. {\ttfamily this} is returned so it can be chained. 

 \label{_get}%
 \subsubsection*{bl.\+get(index)}

{\ttfamily get()} will return the byte at the specified index. 

 \label{_slice}%
 \subsubsection*{bl.\+slice(\mbox{[} start, \mbox{[} end \mbox{]} \mbox{]})}

{\ttfamily slice()} returns a new {\ttfamily Buffer} object containing the bytes within the range specified. Both {\ttfamily start} and {\ttfamily end} are optional and will default to the beginning and end of the list respectively.

If the requested range spans a single internal buffer then a slice of that buffer will be returned which shares the original memory range of that Buffer. If the range spans multiple buffers then copy operations will likely occur to give you a uniform Buffer. 

 \label{_shallowSlice}%
 \subsubsection*{bl.\+shallow\+Slice(\mbox{[} start, \mbox{[} end \mbox{]} \mbox{]})}

{\ttfamily shallow\+Slice()} returns a new {\ttfamily Buffer\+List} object containing the bytes within the range specified. Both {\ttfamily start} and {\ttfamily end} are optional and will default to the beginning and end of the list respectively.

No copies will be performed. All buffers in the result share memory with the original list. 

 \label{_copy}%
 \subsubsection*{bl.\+copy(dest, \mbox{[} dest\+Start, \mbox{[} src\+Start \mbox{[}, src\+End \mbox{]} \mbox{]} \mbox{]})}

{\ttfamily copy()} copies the content of the list in the {\ttfamily dest} buffer, starting from {\ttfamily dest\+Start} and containing the bytes within the range specified with {\ttfamily src\+Start} to {\ttfamily src\+End}. {\ttfamily dest\+Start}, {\ttfamily start} and {\ttfamily end} are optional and will default to the beginning of the {\ttfamily dest} buffer, and the beginning and end of the list respectively. 

 \label{_duplicate}%
 \subsubsection*{bl.\+duplicate()}

{\ttfamily duplicate()} performs a {\bfseries shallow-\/copy} of the list. The internal Buffers remains the same, so if you change the underlying Buffers, the change will be reflected in both the original and the duplicate. This method is needed if you want to call {\ttfamily consume()} or {\ttfamily pipe()} and still keep the original list.\+Example\+:


\begin{DoxyCode}
var bl = new BufferList()

bl.append('hello')
bl.append(' world')
bl.append('\(\backslash\)n')

bl.duplicate().pipe(process.stdout, \{ end: false \})

console.log(bl.toString())
\end{DoxyCode}
 

 \label{_consume}%
 \subsubsection*{bl.\+consume(bytes)}

{\ttfamily consume()} will shift bytes {\itshape off the start of the list}. The number of bytes consumed don\textquotesingle{}t need to line up with the sizes of the internal Buffers---initial offsets will be calculated accordingly in order to give you a consistent view of the data. 

 \label{_toString}%
 \subsubsection*{bl.\+to\+String(\mbox{[}encoding, \mbox{[} start, \mbox{[} end \mbox{]}\mbox{]}\mbox{]})}

{\ttfamily to\+String()} will return a string representation of the buffer. The optional {\ttfamily start} and {\ttfamily end} arguments are passed on to {\ttfamily slice()}, while the {\ttfamily encoding} is passed on to {\ttfamily to\+String()} of the resulting Buffer. See the \href{http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end}{\tt Buffer\+::to\+String()} documentation for more information. 

 \label{_readXX}%
 \subsubsection*{bl.\+read\+Double\+B\+E(), bl.\+read\+Double\+L\+E(), bl.\+read\+Float\+B\+E(), bl.\+read\+Float\+L\+E(), bl.\+read\+Int32\+B\+E(), bl.\+read\+Int32\+L\+E(), bl.\+read\+U\+Int32\+B\+E(), bl.\+read\+U\+Int32\+L\+E(), bl.\+read\+Int16\+B\+E(), bl.\+read\+Int16\+L\+E(), bl.\+read\+U\+Int16\+B\+E(), bl.\+read\+U\+Int16\+L\+E(), bl.\+read\+Int8(), bl.\+read\+U\+Int8()}

All of the standard byte-\/reading methods of the {\ttfamily Buffer} interface are implemented and will operate across internal Buffer boundaries transparently.

See the {\bfseries {\ttfamily \href{http://nodejs.org/docs/latest/api/buffer.html}{\tt Buffer}}} documentation for how these work. 

 \label{_streams}%
 \subsubsection*{Streams}

{\bfseries bl} is a Node {\bfseries \href{http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex}{\tt Duplex Stream}}, so it can be read from and written to like a standard Node stream. You can also {\ttfamily pipe()} to and from a {\bfseries bl} instance. 



\subsection*{Contributors}

{\bfseries bl} is brought to you by the following hackers\+:


\begin{DoxyItemize}
\item \href{https://github.com/rvagg}{\tt Rod Vagg}
\item \href{https://github.com/mcollina}{\tt Matteo Collina}
\item \href{https://github.com/jcrugzz}{\tt Jarett Cruger} 


\end{DoxyItemize}

\label{_license}%
 \subsection*{License \& copyright}

Copyright (c) 2013-\/2016 bl contributors (listed above).

bl is licensed under the M\+IT license. All rights not explicitly granted in the M\+IT license are reserved. See the included L\+I\+C\+E\+N\+S\+E.\+md file for more details. 