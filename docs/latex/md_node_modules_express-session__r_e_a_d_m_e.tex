\href{https://npmjs.org/package/express-session}{\tt } \href{https://npmjs.org/package/express-session}{\tt } \href{https://travis-ci.org/expressjs/session}{\tt } \href{https://coveralls.io/r/expressjs/session?branch=master}{\tt } \href{https://gratipay.com/dougwilson/}{\tt }

\subsection*{Installation}

This is a \href{https://nodejs.org/en/}{\tt Node.\+js} module available through the \href{https://www.npmjs.com/}{\tt npm registry}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\tt {\ttfamily npm install} command}\+:


\begin{DoxyCode}
$ npm install express-session
\end{DoxyCode}


\subsection*{A\+PI}


\begin{DoxyCode}
var session = require('express-session')
\end{DoxyCode}


\subsubsection*{session(options)}

Create a session middleware with the given {\ttfamily options}.

{\bfseries Note} Session data is {\itshape not} saved in the cookie itself, just the session ID. Session data is stored server-\/side.

{\bfseries Note} Since version 1.\+5.\+0, the \href{https://www.npmjs.com/package/cookie-parser}{\tt {\ttfamily cookie-\/parser} middleware} no longer needs to be used for this module to work. This module now directly reads and writes cookies on {\ttfamily req}/{\ttfamily res}. Using {\ttfamily cookie-\/parser} may result in issues if the {\ttfamily secret} is not the same between this module and {\ttfamily cookie-\/parser}.

{\bfseries Warning} The default server-\/side session storage, {\ttfamily Memory\+Store}, is {\itshape purposely} not designed for a production environment. It will leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing.

For a list of stores, see \href{#compatible-session-stores}{\tt compatible session stores}.

\paragraph*{Options}

{\ttfamily express-\/session} accepts these properties in the options object.

\subparagraph*{cookie}

Settings object for the session ID cookie. The default value is `\{ path\+: '/\textquotesingle{}, http\+Only\+: true, secure\+: false, max\+Age\+: null \}\`{}.

The following are options that can be set in this object.

\subparagraph*{cookie.\+domain}

Specifies the value for the {\ttfamily Domain} {\ttfamily Set-\/\+Cookie} attribute. By default, no domain is set, and most clients will consider the cookie to apply to only the current domain.

\subparagraph*{cookie.\+expires}

Specifies the {\ttfamily Date} object to be the value for the {\ttfamily Expires} {\ttfamily Set-\/\+Cookie} attribute. By default, no expiration is set, and most clients will consider this a \char`\"{}non-\/persistent cookie\char`\"{} and will delete it on a condition like exiting a web browser application.

{\bfseries Note} If both {\ttfamily expires} and {\ttfamily max\+Age} are set in the options, then the last one defined in the object is what is used.

{\bfseries Note} The {\ttfamily expires} option should not be set directly; instead only use the {\ttfamily max\+Age} option.

\subparagraph*{cookie.\+http\+Only}

Specifies the {\ttfamily boolean} value for the {\ttfamily Http\+Only} {\ttfamily Set-\/\+Cookie} attribute. When truthy, the {\ttfamily Http\+Only} attribute is set, otherwise it is not. By default, the {\ttfamily Http\+Only} attribute is set.

{\bfseries Note} be careful when setting this to {\ttfamily true}, as compliant clients will not allow client-\/side Java\+Script to see the cookie in {\ttfamily document.\+cookie}.

\subparagraph*{cookie.\+max\+Age}

Specifies the {\ttfamily number} (in milliseconds) to use when calculating the {\ttfamily Expires} {\ttfamily Set-\/\+Cookie} attribute. This is done by taking the current server time and adding {\ttfamily max\+Age} milliseconds to the value to calculate an {\ttfamily Expires} datetime. By default, no maximum age is set.

{\bfseries Note} If both {\ttfamily expires} and {\ttfamily max\+Age} are set in the options, then the last one defined in the object is what is used.

\subparagraph*{cookie.\+path}

Specifies the value for the {\ttfamily Path} {\ttfamily Set-\/\+Cookie}. By default, this is set to `'/\textquotesingle{}\`{}, which is the root path of the domain.

\subparagraph*{cookie.\+same\+Site}

Specifies the {\ttfamily boolean} or {\ttfamily string} to be the value for the {\ttfamily Same\+Site} {\ttfamily Set-\/\+Cookie} attribute.


\begin{DoxyItemize}
\item {\ttfamily true} will set the {\ttfamily Same\+Site} attribute to {\ttfamily Strict} for strict same site enforcement.
\item {\ttfamily false} will not set the {\ttfamily Same\+Site} attribute.
\item `\textquotesingle{}lax'{\ttfamily will set the}Same\+Site{\ttfamily attribute to}Lax{\ttfamily for lax same site enforcement. -\/}\textquotesingle{}strict\textquotesingle{}{\ttfamily will set the}Same\+Site{\ttfamily attribute to}Strict\`{} for strict same site enforcement.
\end{DoxyItemize}

More information about the different enforcement levels can be found in the specification \href{https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1.1}{\tt https\+://tools.\+ietf.\+org/html/draft-\/west-\/first-\/party-\/cookies-\/07\#section-\/4.\+1.\+1}

{\bfseries Note} This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.

\subparagraph*{cookie.\+secure}

Specifies the {\ttfamily boolean} value for the {\ttfamily Secure} {\ttfamily Set-\/\+Cookie} attribute. When truthy, the {\ttfamily Secure} attribute is set, otherwise it is not. By default, the {\ttfamily Secure} attribute is not set.

{\bfseries Note} be careful when setting this to {\ttfamily true}, as compliant clients will not send the cookie back to the server in the future if the browser does not have an H\+T\+T\+PS connection.

Please note that {\ttfamily secure\+: true} is a {\bfseries recommended} option. However, it requires an https-\/enabled website, i.\+e., H\+T\+T\+PS is necessary for secure cookies. If {\ttfamily secure} is set, and you access your site over H\+T\+TP, the cookie will not be set. If you have your node.\+js behind a proxy and are using {\ttfamily secure\+: true}, you need to set \char`\"{}trust proxy\char`\"{} in express\+:


\begin{DoxyCode}
var app = express()
app.set('trust proxy', 1) // trust first proxy
app.use(session(\{
  secret: 'keyboard cat',
  resave: false,
  saveUninitialized: true,
  cookie: \{ secure: true \}
\}))
\end{DoxyCode}


For using secure cookies in production, but allowing for testing in development, the following is an example of enabling this setup based on {\ttfamily N\+O\+D\+E\+\_\+\+E\+NV} in express\+:


\begin{DoxyCode}
var app = express()
var sess = \{
  secret: 'keyboard cat',
  cookie: \{\}
\}

if (app.get('env') === 'production') \{
  app.set('trust proxy', 1) // trust first proxy
  sess.cookie.secure = true // serve secure cookies
\}

app.use(session(sess))
\end{DoxyCode}


The {\ttfamily cookie.\+secure} option can also be set to the special value `\textquotesingle{}auto'\`{} to have this setting automatically match the determined security of the connection. Be careful when using this setting if the site is available both as H\+T\+TP and H\+T\+T\+PS, as once the cookie is set on H\+T\+T\+PS, it will no longer be visible over H\+T\+TP. This is useful when the Express {\ttfamily \char`\"{}trust proxy\char`\"{}} setting is properly setup to simplify development vs production configuration.

\subparagraph*{genid}

Function to call to generate a new session ID. Provide a function that returns a string that will be used as a session ID. The function is given {\ttfamily req} as the first argument if you want to use some value attached to {\ttfamily req} when generating the ID.

The default value is a function which uses the {\ttfamily uid-\/safe} library to generate I\+Ds.

{\bfseries N\+O\+TE} be careful to generate unique I\+Ds so your sessions do not conflict.


\begin{DoxyCode}
app.use(session(\{
  genid: function(req) \{
    return genuuid() // use UUIDs for session IDs
  \},
  secret: 'keyboard cat'
\}))
\end{DoxyCode}


\subparagraph*{name}

The name of the session ID cookie to set in the response (and read from in the request).

The default value is `\textquotesingle{}connect.\+sid'\`{}.

{\bfseries Note} if you have multiple apps running on the same hostname (this is just the name, i.\+e. {\ttfamily localhost} or {\ttfamily 127.\+0.\+0.\+1}; different schemes and ports do not name a different hostname), then you need to separate the session cookies from each other. The simplest method is to simply set different {\ttfamily name}s per app.

\subparagraph*{proxy}

Trust the reverse proxy when setting secure cookies (via the \char`\"{}\+X-\/\+Forwarded-\/\+Proto\char`\"{} header).

The default value is {\ttfamily undefined}.


\begin{DoxyItemize}
\item {\ttfamily true} The \char`\"{}\+X-\/\+Forwarded-\/\+Proto\char`\"{} header will be used.
\item {\ttfamily false} All headers are ignored and the connection is considered secure only if there is a direct T\+L\+S/\+S\+SL connection.
\item {\ttfamily undefined} Uses the \char`\"{}trust proxy\char`\"{} setting from express
\end{DoxyItemize}

\subparagraph*{resave}

Forces the session to be saved back to the session store, even if the session was never modified during the request. Depending on your store this may be necessary, but it can also create race conditions where a client makes two parallel requests to your server and changes made to the session in one request may get overwritten when the other request ends, even if it made no changes (this behavior also depends on what store you\textquotesingle{}re using).

The default value is {\ttfamily true}, but using the default has been deprecated, as the default will change in the future. Please research into this setting and choose what is appropriate to your use-\/case. Typically, you\textquotesingle{}ll want {\ttfamily false}.

How do I know if this is necessary for my store? The best way to know is to check with your store if it implements the {\ttfamily touch} method. If it does, then you can safely set {\ttfamily resave\+: false}. If it does not implement the {\ttfamily touch} method and your store sets an expiration date on stored sessions, then you likely need {\ttfamily resave\+: true}.

\subparagraph*{rolling}

Force a session identifier cookie to be set on every response. The expiration is reset to the original \href{#cookiemaxage}{\tt {\ttfamily max\+Age}}, resetting the expiration countdown.

The default value is {\ttfamily false}.

{\bfseries Note} When this option is set to {\ttfamily true} but the {\ttfamily save\+Uninitialized} option is set to {\ttfamily false}, the cookie will not be set on a response with an uninitialized session.

\subparagraph*{save\+Uninitialized}

Forces a session that is \char`\"{}uninitialized\char`\"{} to be saved to the store. A session is uninitialized when it is new but not modified. Choosing {\ttfamily false} is useful for implementing login sessions, reducing server storage usage, or complying with laws that require permission before setting a cookie. Choosing {\ttfamily false} will also help with race conditions where a client makes multiple parallel requests without a session.

The default value is {\ttfamily true}, but using the default has been deprecated, as the default will change in the future. Please research into this setting and choose what is appropriate to your use-\/case.

{\bfseries Note} if you are using Session in conjunction with Passport\+JS, Passport will add an empty Passport object to the session for use after a user is authenticated, which will be treated as a modification to the session, causing it to be saved. {\itshape This has been fixed in Passport\+JS 0.\+3.\+0}

\subparagraph*{secret}

{\bfseries Required option}

This is the secret used to sign the session ID cookie. This can be either a string for a single secret, or an array of multiple secrets. If an array of secrets is provided, only the first element will be used to sign the session ID cookie, while all the elements will be considered when verifying the signature in requests.

\subparagraph*{store}

The session store instance, defaults to a new {\ttfamily Memory\+Store} instance.

\subparagraph*{unset}

Control the result of unsetting {\ttfamily req.\+session} (through {\ttfamily delete}, setting to {\ttfamily null}, etc.).

The default value is `\textquotesingle{}keep'\`{}.


\begin{DoxyItemize}
\item `\textquotesingle{}destroy'{\ttfamily The session will be destroyed (deleted) when the response ends. -\/}\textquotesingle{}keep\textquotesingle{}\`{} The session in the store will be kept, but modifications made during the request are ignored and not saved.
\end{DoxyItemize}

\subsubsection*{req.\+session}

To store or access session data, simply use the request property {\ttfamily req.\+session}, which is (generally) serialized as J\+S\+ON by the store, so nested objects are typically fine. For example below is a user-\/specific view counter\+:


\begin{DoxyCode}
// Use the session middleware
app.use(session(\{ secret: 'keyboard cat', cookie: \{ maxAge: 60000 \}\}))

// Access the session as req.session
app.get('/', function(req, res, next) \{
  if (req.session.views) \{
    req.session.views++
    res.setHeader('Content-Type', 'text/html')
    res.write('<p>views: ' + req.session.views + '</p>')
    res.write('<p>expires in: ' + (req.session.cookie.maxAge / 1000) + 's</p>')
    res.end()
  \} else \{
    req.session.views = 1
    res.end('welcome to the session demo. refresh!')
  \}
\})
\end{DoxyCode}


\paragraph*{Session.\+regenerate(callback)}

To regenerate the session simply invoke the method. Once complete, a new S\+ID and {\ttfamily Session} instance will be initialized at {\ttfamily req.\+session} and the {\ttfamily callback} will be invoked.


\begin{DoxyCode}
req.session.regenerate(function(err) \{
  // will have a new session here
\})
\end{DoxyCode}


\paragraph*{Session.\+destroy(callback)}

Destroys the session and will unset the {\ttfamily req.\+session} property. Once complete, the {\ttfamily callback} will be invoked.


\begin{DoxyCode}
req.session.destroy(function(err) \{
  // cannot access session here
\})
\end{DoxyCode}


\paragraph*{Session.\+reload(callback)}

Reloads the session data from the store and re-\/populates the {\ttfamily req.\+session} object. Once complete, the {\ttfamily callback} will be invoked.


\begin{DoxyCode}
req.session.reload(function(err) \{
  // session updated
\})
\end{DoxyCode}


\paragraph*{Session.\+save(callback)}

Save the session back to the store, replacing the contents on the store with the contents in memory (though a store may do something else--consult the store\textquotesingle{}s documentation for exact behavior).

This method is automatically called at the end of the H\+T\+TP response if the session data has been altered (though this behavior can be altered with various options in the middleware constructor). Because of this, typically this method does not need to be called.

There are some cases where it is useful to call this method, for example, redirects, long-\/lived requests or in Web\+Sockets.


\begin{DoxyCode}
req.session.save(function(err) \{
  // session saved
\})
\end{DoxyCode}


\paragraph*{Session.\+touch()}

Updates the {\ttfamily .max\+Age} property. Typically this is not necessary to call, as the session middleware does this for you.

\subsubsection*{req.\+session.\+id}

Each session has a unique ID associated with it. This property is an alias of \href{#reqsessionid-1}{\tt {\ttfamily req.\+session\+ID}} and cannot be modified. It has been added to make the session ID accessible from the {\ttfamily session} object.

\subsubsection*{req.\+session.\+cookie}

Each session has a unique cookie object accompany it. This allows you to alter the session cookie per visitor. For example we can set {\ttfamily req.\+session.\+cookie.\+expires} to {\ttfamily false} to enable the cookie to remain for only the duration of the user-\/agent.

\paragraph*{Cookie.\+max\+Age}

Alternatively {\ttfamily req.\+session.\+cookie.\+max\+Age} will return the time remaining in milliseconds, which we may also re-\/assign a new value to adjust the {\ttfamily .expires} property appropriately. The following are essentially equivalent


\begin{DoxyCode}
var hour = 3600000
req.session.cookie.expires = new Date(Date.now() + hour)
req.session.cookie.maxAge = hour
\end{DoxyCode}


For example when {\ttfamily max\+Age} is set to {\ttfamily 60000} (one minute), and 30 seconds has elapsed it will return {\ttfamily 30000} until the current request has completed, at which time {\ttfamily req.\+session.\+touch()} is called to reset {\ttfamily req.\+session.\+max\+Age} to its original value.


\begin{DoxyCode}
req.session.cookie.maxAge // => 30000
\end{DoxyCode}


\subsubsection*{req.\+session\+ID}

To get the ID of the loaded session, access the request property {\ttfamily req.\+session\+ID}. This is simply a read-\/only value set when a session is loaded/created.

\subsection*{Session Store Implementation}

Every session store {\itshape must} be an {\ttfamily Event\+Emitter} and implement specific methods. The following methods are the list of {\bfseries required}, {\bfseries recommended}, and {\bfseries optional}.


\begin{DoxyItemize}
\item Required methods are ones that this module will always call on the store.
\item Recommended methods are ones that this module will call on the store if available.
\item Optional methods are ones this module does not call at all, but helps present uniform stores to users.
\end{DoxyItemize}

For an example implementation view the \href{http://github.com/visionmedia/connect-redis}{\tt connect-\/redis} repo.

\subsubsection*{store.\+all(callback)}

{\bfseries Optional}

This optional method is used to get all sessions in the store as an array. The {\ttfamily callback} should be called as {\ttfamily callback(error, sessions)}.

\subsubsection*{store.\+destroy(sid, callback)}

{\bfseries Required}

This required method is used to destroy/delete a session from the store given a session ID ({\ttfamily sid}). The {\ttfamily callback} should be called as {\ttfamily callback(error)} once the session is destroyed.

\subsubsection*{store.\+clear(callback)}

{\bfseries Optional}

This optional method is used to delete all sessions from the store. The {\ttfamily callback} should be called as {\ttfamily callback(error)} once the store is cleared.

\subsubsection*{store.\+length(callback)}

{\bfseries Optional}

This optional method is used to get the count of all sessions in the store. The {\ttfamily callback} should be called as {\ttfamily callback(error, len)}.

\subsubsection*{store.\+get(sid, callback)}

{\bfseries Required}

This required method is used to get a session from the store given a session ID ({\ttfamily sid}). The {\ttfamily callback} should be called as {\ttfamily callback(error, session)}.

The {\ttfamily session} argument should be a session if found, otherwise {\ttfamily null} or {\ttfamily undefined} if the session was not found (and there was no error). A special case is made when `error.\+code === \textquotesingle{}E\+N\+O\+E\+NT'{\ttfamily to act like}callback(null, null)\`{}.

\subsubsection*{store.\+set(sid, session, callback)}

{\bfseries Required}

This required method is used to upsert a session into the store given a session ID ({\ttfamily sid}) and session ({\ttfamily session}) object. The callback should be called as {\ttfamily callback(error)} once the session has been set in the store.

\subsubsection*{store.\+touch(sid, session, callback)}

{\bfseries Recommended}

This recommended method is used to \char`\"{}touch\char`\"{} a given session given a session ID ({\ttfamily sid}) and session ({\ttfamily session}) object. The {\ttfamily callback} should be called as {\ttfamily callback(error)} once the session has been touched.

This is primarily used when the store will automatically delete idle sessions and this method is used to signal to the store the given session is active, potentially resetting the idle timer.

\subsection*{Compatible Session Stores}

The following modules implement a session store that is compatible with this module. Please make a PR to add additional modules \+:)

\href{https://www.npmjs.com/package/aerospike-session-store}{\tt aerospike-\/session-\/store} A session store using \href{http://www.aerospike.com/}{\tt Aerospike}.

\href{https://www.npmjs.com/package/cassandra-store}{\tt cassandra-\/store} An Apache Cassandra-\/based session store.

\href{https://www.npmjs.com/package/cluster-store}{\tt cluster-\/store} A wrapper for using in-\/process / embedded stores -\/ such as S\+Q\+Lite (via knex), leveldb, files, or memory -\/ with node cluster (desirable for Raspberry Pi 2 and other multi-\/core embedded devices).

\href{https://www.npmjs.com/package/connect-azuretables}{\tt connect-\/azuretables} An \href{https://azure.microsoft.com/en-gb/services/storage/tables/}{\tt Azure Table Storage}-\/based session store.

\href{https://www.npmjs.com/package/connect-cloudant-store}{\tt connect-\/cloudant-\/store} An \href{https://cloudant.com/}{\tt I\+BM Cloudant}-\/based session store.

\href{https://www.npmjs.com/package/connect-couchbase}{\tt connect-\/couchbase} A \href{http://www.couchbase.com/}{\tt couchbase}-\/based session store.

\href{https://www.npmjs.com/package/connect-datacache}{\tt connect-\/datacache} An \href{http://www.ibm.com/cloud-computing/bluemix/}{\tt I\+BM Bluemix Data Cache}-\/based session store.

\href{https://www.npmjs.com/package/connect-db2}{\tt connect-\/db2} An I\+BM D\+B2-\/based session store built using \href{https://www.npmjs.com/package/ibm_db}{\tt ibm\+\_\+db} module.

\href{https://github.com/ca98am79/connect-dynamodb}{\tt connect-\/dynamodb} A Dynamo\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/connect-loki}{\tt connect-\/loki} A Loki.\+js-\/based session store.

\href{https://www.npmjs.com/package/connect-ml}{\tt connect-\/ml} A Mark\+Logic Server-\/based session store.

\href{https://www.npmjs.com/package/connect-mssql}{\tt connect-\/mssql} A S\+QL Server-\/based session store.

\href{https://www.npmjs.com/package/connect-monetdb}{\tt connect-\/monetdb} A Monet\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/connect-mongo}{\tt connect-\/mongo} A Mongo\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/connect-mongodb-session}{\tt connect-\/mongodb-\/session} Lightweight Mongo\+D\+B-\/based session store built and maintained by Mongo\+DB.

\href{https://www.npmjs.com/package/connect-pg-simple}{\tt connect-\/pg-\/simple} A Postgre\+S\+Q\+L-\/based session store.

\href{https://www.npmjs.com/package/connect-redis}{\tt connect-\/redis} A Redis-\/based session store.

\href{https://www.npmjs.com/package/connect-memcached}{\tt connect-\/memcached} A memcached-\/based session store.

\href{https://www.npmjs.com/package/connect-memjs}{\tt connect-\/memjs} A memcached-\/based session store using \href{https://www.npmjs.com/package/memjs}{\tt memjs} as the memcached client.

\href{https://www.npmjs.com/package/connect-session-knex}{\tt connect-\/session-\/knex} A session store using \href{http://knexjs.org/}{\tt Knex.\+js}, which is a S\+QL query builder for Postgre\+S\+QL, My\+S\+QL, Maria\+DB, S\+Q\+Lite3, and Oracle.

\href{https://www.npmjs.com/package/connect-session-sequelize}{\tt connect-\/session-\/sequelize} A session store using \href{http://sequelizejs.com/}{\tt Sequelize.\+js}, which is a Node.\+js / io.\+js O\+RM for Postgre\+S\+QL, My\+S\+QL, S\+Q\+Lite and M\+S\+S\+QL.

\href{https://www.npmjs.com/package/dynamodb-store}{\tt dynamodb-\/store} A Dynamo\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/express-mysql-session}{\tt express-\/mysql-\/session} A session store using native \href{https://www.mysql.com/}{\tt My\+S\+QL} via the \href{https://github.com/felixge/node-mysql}{\tt node-\/mysql} module.

\href{https://www.npmjs.com/package/express-oracle-session}{\tt express-\/oracle-\/session} A session store using native \href{https://www.oracle.com/}{\tt oracle} via the \href{https://www.npmjs.com/package/oracledb}{\tt node-\/oracledb} module.

\href{https://www.npmjs.com/package/express-sessions}{\tt express-\/sessions}\+: A session store supporting both Mongo\+DB and Redis.

\href{https://www.npmjs.com/package/connect-sqlite3}{\tt connect-\/sqlite3} A \href{https://github.com/mapbox/node-sqlite3}{\tt S\+Q\+Lite3} session store modeled after the TJ\textquotesingle{}s {\ttfamily connect-\/redis} store.

\href{https://www.npmjs.com/package/documentdb-session}{\tt documentdb-\/session} A session store for Microsoft Azure\textquotesingle{}s \href{https://azure.microsoft.com/en-us/services/documentdb/}{\tt Document\+DB} No\+S\+QL database service.

\href{https://www.npmjs.com/package/express-nedb-session}{\tt express-\/nedb-\/session} A Ne\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/express-session-cache-manager}{\tt express-\/session-\/cache-\/manager} A store that implements \href{https://www.npmjs.com/package/cache-manager}{\tt cache-\/manager}, which supports a \href{https://www.npmjs.com/package/cache-manager#store-engines}{\tt variety of storage types}.

\href{https://www.npmjs.com/package/express-session-level}{\tt express-\/session-\/level} A \href{https://github.com/Level/levelup}{\tt Level\+DB} based session store.

\href{https://www.npmjs.com/package/express-etcd}{\tt express-\/etcd} An \href{https://github.com/stianeikeland/node-etcd}{\tt etcd} based session store.

\href{https://www.npmjs.com/package/fortune-session}{\tt fortune-\/session} A \href{https://github.com/fortunejs/fortune}{\tt Fortune.\+js} based session store. Supports all backends supported by Fortune (Mongo\+DB, Redis, Postgres, Ne\+DB).

\href{https://www.npmjs.com/package/hazelcast-store}{\tt hazelcast-\/store} A Hazelcast-\/based session store built on the \href{https://www.npmjs.com/package/hazelcast-client}{\tt Hazelcast Node Client}.

\href{https://www.npmjs.com/package/level-session-store}{\tt level-\/session-\/store} A Level\+D\+B-\/based session store.

\href{https://www.npmjs.com/package/medea-session-store}{\tt medea-\/session-\/store} A Medea-\/based session store.

\href{https://www.npmjs.com/package/memorystore}{\tt memorystore} A memory session store made for production.

\href{https://www.npmjs.com/package/mssql-session-store}{\tt mssql-\/session-\/store} A S\+QL Server-\/based session store.

\href{https://www.npmjs.com/package/nedb-session-store}{\tt nedb-\/session-\/store} An alternate Ne\+D\+B-\/based (either in-\/memory or file-\/persisted) session store.

\href{https://www.npmjs.com/package/sequelstore-connect}{\tt sequelstore-\/connect} A session store using \href{http://sequelizejs.com/}{\tt Sequelize.\+js}.

\href{https://www.npmjs.com/package/session-file-store}{\tt session-\/file-\/store} A file system-\/based session store.

\href{https://www.npmjs.com/package/session-rethinkdb}{\tt session-\/rethinkdb} A \href{http://rethinkdb.com/}{\tt Rethink\+DB}-\/based session store.

\subsection*{Example}

A simple example using {\ttfamily express-\/session} to store page views for a user.


\begin{DoxyCode}
var express = require('express')
var parseurl = require('parseurl')
var session = require('express-session')

var app = express()

app.use(session(\{
  secret: 'keyboard cat',
  resave: false,
  saveUninitialized: true
\}))

app.use(function (req, res, next) \{
  if (!req.session.views) \{
    req.session.views = \{\}
  \}

  // get the url pathname
  var pathname = parseurl(req).pathname

  // count the views
  req.session.views[pathname] = (req.session.views[pathname] || 0) + 1

  next()
\})

app.get('/foo', function (req, res, next) \{
  res.send('you viewed this page ' + req.session.views['/foo'] + ' times')
\})

app.get('/bar', function (req, res, next) \{
  res.send('you viewed this page ' + req.session.views['/bar'] + ' times')
\})
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 