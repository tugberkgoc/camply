\begin{quote}
Same same, but different \end{quote}


{\ttfamily samsam} is a collection of predicate and comparison functions useful for identifiying the type of values and to compare values with varying degrees of strictness.

{\ttfamily samsam} is a general-\/purpose library with no dependencies. It works in browsers (including old and rowdy ones, like I\+E6) and Node. It will define itself as an A\+MD module if you want it to (i.\+e. if there\textquotesingle{}s a {\ttfamily define} function available).

\subsection*{Predicate functions}

\subsubsection*{{\ttfamily is\+Arguments(object)}}

Returns {\ttfamily true} if {\ttfamily object} is an {\ttfamily arguments} object, {\ttfamily false} otherwise.

\subsubsection*{{\ttfamily is\+Neg\+Zero(value)}}

Returns {\ttfamily true} if {\ttfamily value} is {\ttfamily -\/0}.

\subsubsection*{{\ttfamily is\+Element(object)}}

Returns {\ttfamily true} if {\ttfamily object} is a D\+OM element node. Unlike Underscore.\+js/lodash, this function will return {\ttfamily false} if {\ttfamily object} is an {\itshape element-\/like} object, i.\+e. a regular object with a {\ttfamily node\+Type} property that holds the value {\ttfamily 1}.

\subsection*{Comparison functions}

\subsubsection*{{\ttfamily identical(x, y)}}

Strict equality check according to Ecma\+Script Harmony\textquotesingle{}s {\ttfamily egal}.

{\bfseries From the Harmony wiki\+:}

\begin{quote}
An egal function simply makes available the internal {\ttfamily Same\+Value} function \end{quote}
from section 9.\+12 of the E\+S5 spec. If two values are egal, then they are not observably distinguishable.

{\ttfamily identical} returns {\ttfamily true} when {\ttfamily ===} is {\ttfamily true}, except for {\ttfamily -\/0} and {\ttfamily +0}, where it returns {\ttfamily false}. Additionally, it returns {\ttfamily true} when {\ttfamily NaN} is compared to itself.

\subsubsection*{{\ttfamily deep\+Equal(obj1, obj2)}}

Deep equal comparison. Two values are \char`\"{}deep equal\char`\"{} if\+:


\begin{DoxyItemize}
\item They are identical
\item They are both date objects representing the same time
\item They are both arrays containing elements that are all deep\+Equal
\item They are objects with the same set of properties, and each property in {\ttfamily obj1} is deep\+Equal to the corresponding property in {\ttfamily obj2}
\end{DoxyItemize}

\subsubsection*{{\ttfamily match(object, matcher)}}

Partial equality check. Compares {\ttfamily object} with matcher according a wide set of rules\+:

\paragraph*{String matcher}

In its simplest form, {\ttfamily match} performs a case insensitive substring match. When the matcher is a string, {\ttfamily object} is converted to a string, and the function returns {\ttfamily true} if the matcher is a case-\/insensitive substring of {\ttfamily object} as a string.


\begin{DoxyCode}
samsam.match("Give me something", "Give"); //true
samsam.match("Give me something", "sumptn"); // false
samsam.match(\{ toString: function () \{ return "yeah"; \} \}, "Yeah!"); // true
\end{DoxyCode}


The last example is not symmetric. When the matcher is a string, the {\ttfamily object} is coerced to a string -\/ in this case using {\ttfamily to\+String}. Changing the order of the arguments would cause the matcher to be an object, in which case different rules apply (see below).

\paragraph*{Boolean matcher}

Performs a strict (i.\+e. {\ttfamily ===}) match with the object. So, only {\ttfamily true} matches {\ttfamily true}, and only {\ttfamily false} matches {\ttfamily false}.

\paragraph*{Regular expression matcher}

When the matcher is a regular expression, the function will pass if {\ttfamily object.\+test(matcher)} is {\ttfamily true}. {\ttfamily match} is written in a generic way, so any object with a {\ttfamily test} method will be used as a matcher this way.


\begin{DoxyCode}
samsam.match("Give me something", /^[a-z\(\backslash\)s]$/i); // true
samsam.match("Give me something", /[0-9]/); // false
samsam.match(\{ toString: function () \{ return "yeah!"; \} \}, /yeah/); // true
samsam.match(234, /[a-z]/); // false
\end{DoxyCode}


\paragraph*{Number matcher}

When the matcher is a number, the assertion will pass if {\ttfamily object == matcher}.


\begin{DoxyCode}
samsam.match("123", 123); // true
samsam.match("Give me something", 425); // false
samsam.match(\{ toString: function () \{ return "42"; \} \}, 42); // true
samsam.match(234, 1234); // false
\end{DoxyCode}


\paragraph*{Function matcher}

When the matcher is a function, it is called with {\ttfamily object} as its only argument. {\ttfamily match} returns {\ttfamily true} if the function returns {\ttfamily true}. A strict match is performed against the return value, so a boolean {\ttfamily true} is required, truthy is not enough.


\begin{DoxyCode}
// true
samsam.match("123", function (exp) \{
    return exp == "123";
\});

// false
samsam.match("Give me something", function () \{
    return "ok";
\});

// true
samsam.match(\{
    toString: function () \{
        return "42";
    \}
\}, function () \{ return true; \});

// false
samsam.match(234, function () \{\});
\end{DoxyCode}


\paragraph*{Object matcher}

As mentioned above, if an object matcher defines a {\ttfamily test} method, {\ttfamily match} will return {\ttfamily true} if {\ttfamily matcher.\+test(object)} returns truthy.

If the matcher does not have a test method, a recursive match is performed. If all properties of {\ttfamily matcher} matches corresponding properties in {\ttfamily object}, {\ttfamily match} returns {\ttfamily true}. Note that the object matcher does not care if the number of properties in the two objects are the same -\/ only if all properties in the matcher recursively matches ones in {\ttfamily object}.


\begin{DoxyCode}
// true
samsam.match("123", \{
    test: function (arg) \{
        return arg == 123;
    \}
\});

// false
samsam.match(\{\}, \{ prop: 42 \});

// true
samsam.match(\{
    name: "Chris",
    profession: "Programmer"
\}, \{
    name: "Chris"
\});

// false
samsam.match(234, \{ name: "Chris" \});
\end{DoxyCode}


\paragraph*{D\+OM elements}

{\ttfamily match} can be very helpful when comparing D\+OM elements, because it allows you to compare several properties with one call\+:


\begin{DoxyCode}
var el = document.getElementById("myEl");

samsam.match(el, \{
    tagName: "h2",
    className: "item",
    innerHTML: "Howdy"
\});
\end{DoxyCode}
 