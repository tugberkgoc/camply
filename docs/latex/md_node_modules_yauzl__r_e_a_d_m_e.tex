\href{https://travis-ci.org/thejoshwolfe/yauzl}{\tt } \href{https://coveralls.io/r/thejoshwolfe/yauzl}{\tt }

yet another unzip library for node. For zipping, see \href{https://github.com/thejoshwolfe/yazl}{\tt yazl}.

Design principles\+:


\begin{DoxyItemize}
\item Follow the spec. Don\textquotesingle{}t scan for local file headers. Read the central directory for file metadata. (see \href{#no-streaming-unzip-api}{\tt No Streaming Unzip A\+PI}).
\item Don\textquotesingle{}t block the Java\+Script thread. Use and provide async A\+P\+Is.
\item Keep memory usage under control. Don\textquotesingle{}t attempt to buffer entire files in R\+AM at once.
\item Never crash (if used properly). Don\textquotesingle{}t let malformed zip files bring down client applications who are trying to catch errors.
\item Catch unsafe file names. See {\ttfamily validate\+File\+Name()}.
\end{DoxyItemize}

\subsection*{Usage}


\begin{DoxyCode}
var yauzl = require("yauzl");

yauzl.open("path/to/file.zip", \{lazyEntries: true\}, function(err, zipfile) \{
  if (err) throw err;
  zipfile.readEntry();
  zipfile.on("entry", function(entry) \{
    if (/\(\backslash\)/$/.test(entry.fileName)) \{
      // Directory file names end with '/'.
      // Note that entires for directories themselves are optional.
      // An entry's fileName implicitly requires its parent directories to exist.
      zipfile.readEntry();
    \} else \{
      // file entry
      zipfile.openReadStream(entry, function(err, readStream) \{
        if (err) throw err;
        readStream.on("end", function() \{
          zipfile.readEntry();
        \});
        readStream.pipe(somewhere);
      \});
    \}
  \});
\});
\end{DoxyCode}


See also {\ttfamily examples/} for more usage examples.

\subsection*{A\+PI}

The default for every optional {\ttfamily callback} parameter is\+:


\begin{DoxyCode}
function defaultCallback(err) \{
  if (err) throw err;
\}
\end{DoxyCode}


\subsubsection*{open(path, \mbox{[}options\mbox{]}, \mbox{[}callback\mbox{]})}

Calls {\ttfamily fs.\+open(path, \char`\"{}r\char`\"{})} and reads the {\ttfamily fd} effectively the same as {\ttfamily from\+Fd()} would.

{\ttfamily options} may be omitted or {\ttfamily null}. The defaults are {\ttfamily \{auto\+Close\+: true, lazy\+Entries\+: false, decode\+Strings\+: true, validate\+Entry\+Sizes\+: true, strict\+File\+Names\+: false\}}.

{\ttfamily auto\+Close} is effectively equivalent to\+:


\begin{DoxyCode}
zipfile.once("end", function() \{
  zipfile.close();
\});
\end{DoxyCode}


{\ttfamily lazy\+Entries} indicates that entries should be read only when {\ttfamily read\+Entry()} is called. If {\ttfamily lazy\+Entries} is {\ttfamily false}, {\ttfamily entry} events will be emitted as fast as possible to allow {\ttfamily pipe()}ing file data from all entries in parallel. This is not recommended, as it can lead to out of control memory usage for zip files with many entries. See \href{https://github.com/thejoshwolfe/yauzl/issues/22}{\tt issue \#22}. If {\ttfamily lazy\+Entries} is {\ttfamily true}, an {\ttfamily entry} or {\ttfamily end} event will be emitted in response to each call to {\ttfamily read\+Entry()}. This allows processing of one entry at a time, and will keep memory usage under control for zip files with many entries.

{\ttfamily decode\+Strings} is the default and causes yauzl to decode strings with {\ttfamily C\+P437} or {\ttfamily U\+T\+F-\/8} as required by the spec. The exact effects of turning this option off are\+:


\begin{DoxyItemize}
\item {\ttfamily zipfile.\+comment}, {\ttfamily entry.\+file\+Name}, and {\ttfamily entry.\+file\+Comment} will be {\ttfamily Buffer} objects instead of {\ttfamily String}s.
\item Any Info-\/\+Z\+IP Unicode Path Extra Field will be ignored. See {\ttfamily extra\+Fields}.
\item Automatic file name validation will not be performed. See {\ttfamily validate\+File\+Name()}.
\end{DoxyItemize}

{\ttfamily validate\+Entry\+Sizes} is the default and ensures that an entry\textquotesingle{}s reported uncompressed size matches its actual uncompressed size. This check happens as early as possible, which is either before emitting each {\ttfamily \char`\"{}entry\char`\"{}} event (for entries with no compression), or during the {\ttfamily read\+Stream} piping after calling {\ttfamily open\+Read\+Stream()}. See {\ttfamily open\+Read\+Stream()} for more information on defending against zip bomb attacks.

When {\ttfamily strict\+File\+Names} is {\ttfamily false} (the default) and {\ttfamily decode\+Strings} is {\ttfamily true}, all backslash ({\ttfamily \textbackslash{}}) characters in each {\ttfamily entry.\+file\+Name} are replaced with forward slashes ({\ttfamily /}). The spec forbids file names with backslashes, but Microsoft\textquotesingle{}s {\ttfamily System.\+I\+O.\+Compression.\+Zip\+File} class in .N\+ET versions 4.\+5.\+0 until 4.\+6.\+1 creates non-\/conformant zipfiles with backslashes in file names. {\ttfamily strict\+File\+Names} is {\ttfamily false} by default so that clients can read these non-\/conformant zipfiles without knowing about this Microsoft-\/specific bug. When {\ttfamily strict\+File\+Names} is {\ttfamily true} and {\ttfamily decode\+Strings} is {\ttfamily true}, entries with backslashes in their file names will result in an error. See {\ttfamily validate\+File\+Name()}. When {\ttfamily decode\+Strings} is {\ttfamily false}, {\ttfamily strict\+File\+Names} has no effect.

The {\ttfamily callback} is given the arguments {\ttfamily (err, zipfile)}. An {\ttfamily err} is provided if the End of Central Directory Record cannot be found, or if its metadata appears malformed. This kind of error usually indicates that this is not a zip file. Otherwise, {\ttfamily zipfile} is an instance of {\ttfamily Zip\+File}.

\subsubsection*{from\+Fd(fd, \mbox{[}options\mbox{]}, \mbox{[}callback\mbox{]})}

Reads from the fd, which is presumed to be an open .zip file. Note that random access is required by the zip file specification, so the fd cannot be an open socket or any other fd that does not support random access.

{\ttfamily options} may be omitted or {\ttfamily null}. The defaults are {\ttfamily \{auto\+Close\+: false, lazy\+Entries\+: false, decode\+Strings\+: true, validate\+Entry\+Sizes\+: true, strict\+File\+Names\+: false\}}.

See {\ttfamily open()} for the meaning of the options and callback.

\subsubsection*{from\+Buffer(buffer, \mbox{[}options\mbox{]}, \mbox{[}callback\mbox{]})}

Like {\ttfamily from\+Fd()}, but reads from a R\+AM buffer instead of an open file. {\ttfamily buffer} is a {\ttfamily Buffer}.

If a {\ttfamily Zip\+File} is acquired from this method, it will never emit the {\ttfamily close} event, and calling {\ttfamily close()} is not necessary.

{\ttfamily options} may be omitted or {\ttfamily null}. The defaults are {\ttfamily \{lazy\+Entries\+: false, decode\+Strings\+: true, validate\+Entry\+Sizes\+: true, strict\+File\+Names\+: false\}}.

See {\ttfamily open()} for the meaning of the options and callback. The {\ttfamily auto\+Close} option is ignored for this method.

\subsubsection*{from\+Random\+Access\+Reader(reader, total\+Size, \mbox{[}options\mbox{]}, \mbox{[}callback\mbox{]})}

This method of reading a zip file allows clients to implement their own back-\/end file system. For example, a client might translate read calls into network requests.

The {\ttfamily reader} parameter must be of a type that is a subclass of \href{#class-randomaccessreader}{\tt Random\+Access\+Reader} that implements the required methods. The {\ttfamily total\+Size} is a Number and indicates the total file size of the zip file.

{\ttfamily options} may be omitted or {\ttfamily null}. The defaults are {\ttfamily \{auto\+Close\+: true, lazy\+Entries\+: false, decode\+Strings\+: true, validate\+Entry\+Sizes\+: true, strict\+File\+Names\+: false\}}.

See {\ttfamily open()} for the meaning of the options and callback.

\subsubsection*{dos\+Date\+Time\+To\+Date(date, time)}

Converts M\+S-\/\+D\+OS {\ttfamily date} and {\ttfamily time} data into a Java\+Script {\ttfamily Date} object. Each parameter is a {\ttfamily Number} treated as an unsigned 16-\/bit integer. Note that this format does not support timezones, so the returned object will use the local timezone.

\subsubsection*{validate\+File\+Name(file\+Name)}

Returns {\ttfamily null} or a {\ttfamily String} error message depending on the validity of {\ttfamily file\+Name}. If {\ttfamily file\+Name} starts with {\ttfamily \char`\"{}/\char`\"{}} or {\ttfamily /\mbox{[}A-\/\+Za-\/z\mbox{]}\+:\textbackslash{}//} or if it contains {\ttfamily \char`\"{}..\char`\"{}} path segments or {\ttfamily \char`\"{}\textbackslash{}\textbackslash{}\char`\"{}}, this function returns an error message appropriate for use like this\+:


\begin{DoxyCode}
var errorMessage = yauzl.validateFileName(fileName);
if (errorMessage != null) throw new Error(errorMessage);
\end{DoxyCode}


This function is automatically run for each entry, as long as {\ttfamily decode\+Strings} is {\ttfamily true}. See {\ttfamily open()}, {\ttfamily strict\+File\+Names}, and {\ttfamily Event\+: \char`\"{}entry\char`\"{}} for more information.

\subsubsection*{Class\+: Zip\+File}

The constructor for the class is not part of the public A\+PI. Use {\ttfamily open()}, {\ttfamily from\+Fd()}, {\ttfamily from\+Buffer()}, or {\ttfamily from\+Random\+Access\+Reader()} instead.

\paragraph*{Event\+: \char`\"{}entry\char`\"{}}

Callback gets {\ttfamily (entry)}, which is an {\ttfamily Entry}. See {\ttfamily open()} and {\ttfamily read\+Entry()} for when this event is emitted.

If {\ttfamily decode\+Strings} is {\ttfamily true}, entries emitted via this event have already passed file name validation. See {\ttfamily validate\+File\+Name()} and {\ttfamily open()} for more information.

If {\ttfamily validate\+Entry\+Sizes} is {\ttfamily true} and this entry\textquotesingle{}s {\ttfamily compression\+Method} is {\ttfamily 0} (stored without compression), this entry has already passed entry size validation. See {\ttfamily open()} for more information.

\paragraph*{Event\+: \char`\"{}end\char`\"{}}

Emitted after the last {\ttfamily entry} event has been emitted. See {\ttfamily open()} and {\ttfamily read\+Entry()} for more info on when this event is emitted.

\paragraph*{Event\+: \char`\"{}close\char`\"{}}

Emitted after the fd is actually closed. This is after calling {\ttfamily close()} (or after the {\ttfamily end} event when {\ttfamily auto\+Close} is {\ttfamily true}), and after all stream pipelines created from {\ttfamily open\+Read\+Stream()} have finished reading data from the fd.

If this {\ttfamily Zip\+File} was acquired from {\ttfamily from\+Random\+Access\+Reader()}, the \char`\"{}fd\char`\"{} in the previous paragraph refers to the {\ttfamily Random\+Access\+Reader} implemented by the client.

If this {\ttfamily Zip\+File} was acquired from {\ttfamily from\+Buffer()}, this event is never emitted.

\paragraph*{Event\+: \char`\"{}error\char`\"{}}

Emitted in the case of errors with reading the zip file. (Note that other errors can be emitted from the streams created from {\ttfamily open\+Read\+Stream()} as well.) After this event has been emitted, no further {\ttfamily entry}, {\ttfamily end}, or {\ttfamily error} events will be emitted, but the {\ttfamily close} event may still be emitted.

\paragraph*{read\+Entry()}

Causes this {\ttfamily Zip\+File} to emit an {\ttfamily entry} or {\ttfamily end} event (or an {\ttfamily error} event). This method must only be called when this {\ttfamily Zip\+File} was created with the {\ttfamily lazy\+Entries} option set to {\ttfamily true} (see {\ttfamily open()}). When this {\ttfamily Zip\+File} was created with the {\ttfamily lazy\+Entries} option set to {\ttfamily true}, {\ttfamily entry} and {\ttfamily end} events are only ever emitted in response to this method call.

The event that is emitted in response to this method will not be emitted until after this method has returned, so it is safe to call this method before attaching event listeners.

After calling this method, calling this method again before the response event has been emitted will cause undefined behavior. Calling this method after the {\ttfamily end} event has been emitted will cause undefined behavior. Calling this method after calling {\ttfamily close()} will cause undefined behavior.

\paragraph*{open\+Read\+Stream(entry, \mbox{[}options\mbox{]}, callback)}

{\ttfamily entry} must be an {\ttfamily Entry} object from this {\ttfamily Zip\+File}. {\ttfamily callback} gets {\ttfamily (err, read\+Stream)}, where {\ttfamily read\+Stream} is a {\ttfamily Readable Stream} that provides the file data for this entry. If this zipfile is already closed (see {\ttfamily close()}), the {\ttfamily callback} will receive an {\ttfamily err}.

{\ttfamily options} may be omitted or {\ttfamily null}, and has the following defaults\+:


\begin{DoxyCode}
\{
  decompress: entry.isCompressed() ? true : null,
  decrypt: null,
  start: 0,                  // actually the default is null, see below
  end: entry.compressedSize, // actually the default is null, see below
\}
\end{DoxyCode}


If the entry is compressed (with a supported compression method), and the {\ttfamily decompress} option is {\ttfamily true} (or omitted), the read stream provides the decompressed data. Omitting the {\ttfamily decompress} option is what most clients should do.

The {\ttfamily decompress} option must be {\ttfamily null} (or omitted) when the entry is not compressed (see {\ttfamily is\+Compressed()}), and either {\ttfamily true} (or omitted) or {\ttfamily false} when the entry is compressed. Specifying {\ttfamily decompress\+: false} for a compressed entry causes the read stream to provide the raw compressed file data without going through a zlib inflate transform.

If the entry is encrypted (see {\ttfamily is\+Encrypted()}), clients may want to avoid calling {\ttfamily open\+Read\+Stream()} on the entry entirely. Alternatively, clients may call {\ttfamily open\+Read\+Stream()} for encrypted entries and specify {\ttfamily decrypt\+: false}. If the entry is also compressed, clients must {\itshape also} specify {\ttfamily decompress\+: false}. Specifying {\ttfamily decrypt\+: false} for an encrypted entry causes the read stream to provide the raw, still-\/encrypted file data. (This data includes the 12-\/byte header described in the spec.)

The {\ttfamily decrypt} option must be {\ttfamily null} (or omitted) for non-\/encrypted entries, and {\ttfamily false} for encrypted entries. Omitting the {\ttfamily decrypt} option (or specifying it as {\ttfamily null}) for an encrypted entry will result in the {\ttfamily callback} receiving an {\ttfamily err}. This default behavior is so that clients not accounting for encrypted files aren\textquotesingle{}t surprised by bogus file data.

The {\ttfamily start} (inclusive) and {\ttfamily end} (exclusive) options are byte offsets into this entry\textquotesingle{}s file data, and can be used to obtain part of an entry\textquotesingle{}s file data rather than the whole thing. If either of these options are specified and non-\/{\ttfamily null}, then the above options must be used to obain the file\textquotesingle{}s raw data. Speficying {\ttfamily \{start\+: 0, end\+: entry.\+compressed\+Size\}} will result in the complete file, which is effectively the default values for these options, but note that unlike omitting the options, when you specify {\ttfamily start} or {\ttfamily end} as any non-\/{\ttfamily null} value, the above requirement is still enforced that you must also pass the appropriate options to get the file\textquotesingle{}s raw data.

It\textquotesingle{}s possible for the {\ttfamily read\+Stream} provided to the {\ttfamily callback} to emit errors for several reasons. For example, if zlib cannot decompress the data, the zlib error will be emitted from the {\ttfamily read\+Stream}. Two more error cases (when {\ttfamily validate\+Entry\+Sizes} is {\ttfamily true}) are if the decompressed data has too many or too few actual bytes compared to the reported byte count from the entry\textquotesingle{}s {\ttfamily uncompressed\+Size} field. yauzl notices this false information and emits an error from the {\ttfamily read\+Stream} after some number of bytes have already been piped through the stream.

This check allows clients to trust the {\ttfamily uncompressed\+Size} field in {\ttfamily Entry} objects. Guarding against \href{http://en.wikipedia.org/wiki/Zip_bomb}{\tt zip bomb} attacks can be accomplished by doing some heuristic checks on the size metadata and then watching out for the above errors. Such heuristics are outside the scope of this library, but enforcing the {\ttfamily uncompressed\+Size} is implemented here as a security feature.

It is possible to destroy the {\ttfamily read\+Stream} before it has piped all of its data. To do this, call {\ttfamily read\+Stream.\+destroy()}. You must {\ttfamily unpipe()} the {\ttfamily read\+Stream} from any destination before calling {\ttfamily read\+Stream.\+destroy()}. If this zipfile was created using {\ttfamily from\+Random\+Access\+Reader()}, the {\ttfamily Random\+Access\+Reader} implementation must provide readable streams that implement a {\ttfamily .destroy()} method (see {\ttfamily random\+Access\+Reader.\+\_\+read\+Stream\+For\+Range()}) in order for calls to {\ttfamily read\+Stream.\+destroy()} to work in this context.

\paragraph*{close()}

Causes all future calls to {\ttfamily open\+Read\+Stream()} to fail, and closes the fd, if any, after all streams created by {\ttfamily open\+Read\+Stream()} have emitted their {\ttfamily end} events.

If the {\ttfamily auto\+Close} option is set to {\ttfamily true} (see {\ttfamily open()}), this function will be called automatically effectively in response to this object\textquotesingle{}s {\ttfamily end} event.

If the {\ttfamily lazy\+Entries} option is set to {\ttfamily false} (see {\ttfamily open()}) and this object\textquotesingle{}s {\ttfamily end} event has not been emitted yet, this function causes undefined behavior. If the {\ttfamily lazy\+Entries} option is set to {\ttfamily true}, you can call this function instead of calling {\ttfamily read\+Entry()} to abort reading the entries of a zipfile.

It is safe to call this function multiple times; after the first call, successive calls have no effect. This includes situations where the {\ttfamily auto\+Close} option effectively calls this function for you.

If {\ttfamily close()} is never called, then the zipfile is \char`\"{}kept open\char`\"{}. For zipfiles created with {\ttfamily from\+Fd()}, this will leave the {\ttfamily fd} open, which may be desirable. For zipfiles created with {\ttfamily open()}, this will leave the underlying {\ttfamily fd} open, thereby \char`\"{}leaking\char`\"{} it, which is probably undesirable. For zipfiles created with {\ttfamily from\+Random\+Access\+Reader()}, the reader\textquotesingle{}s {\ttfamily close()} method will never be called. For zipfiles created with {\ttfamily from\+Buffer()}, the {\ttfamily close()} function has no effect whether called or not.

Regardless of how this {\ttfamily Zip\+File} was created, there are no resources other than those listed above that require cleanup from this function. This means it may be desirable to never call {\ttfamily close()} in some usecases.

\paragraph*{is\+Open}

{\ttfamily Boolean}. {\ttfamily true} until {\ttfamily close()} is called; then it\textquotesingle{}s {\ttfamily false}.

\paragraph*{entry\+Count}

{\ttfamily Number}. Total number of central directory records.

\paragraph*{comment}

{\ttfamily String}. Always decoded with {\ttfamily C\+P437} per the spec.

If {\ttfamily decode\+Strings} is {\ttfamily false} (see {\ttfamily open()}), this field is the undecoded {\ttfamily Buffer} instead of a decoded {\ttfamily String}.

\subsubsection*{Class\+: Entry}

Objects of this class represent Central Directory Records. Refer to the zipfile specification for more details about these fields.

These fields are of type {\ttfamily Number}\+:


\begin{DoxyItemize}
\item {\ttfamily version\+Made\+By}
\item {\ttfamily version\+Needed\+To\+Extract}
\item {\ttfamily general\+Purpose\+Bit\+Flag}
\item {\ttfamily compression\+Method}
\item {\ttfamily last\+Mod\+File\+Time} (M\+S-\/\+D\+OS format, see {\ttfamily get\+Last\+Mod\+Date\+Time})
\item {\ttfamily last\+Mod\+File\+Date} (M\+S-\/\+D\+OS format, see {\ttfamily get\+Last\+Mod\+Date\+Time})
\item {\ttfamily crc32}
\item {\ttfamily compressed\+Size}
\item {\ttfamily uncompressed\+Size}
\item {\ttfamily file\+Name\+Length} (bytes)
\item {\ttfamily extra\+Field\+Length} (bytes)
\item {\ttfamily file\+Comment\+Length} (bytes)
\item {\ttfamily internal\+File\+Attributes}
\item {\ttfamily external\+File\+Attributes}
\item {\ttfamily relative\+Offset\+Of\+Local\+Header}
\end{DoxyItemize}

\paragraph*{file\+Name}

{\ttfamily String}. Following the spec, the bytes for the file name are decoded with {\ttfamily U\+T\+F-\/8} if {\ttfamily general\+Purpose\+Bit\+Flag \& 0x800}, otherwise with {\ttfamily C\+P437}. Alternatively, this field may be populated from the Info-\/\+Z\+IP Unicode Path Extra Field (see {\ttfamily extra\+Fields}).

This field is automatically validated by {\ttfamily validate\+File\+Name()} before yauzl emits an \char`\"{}entry\char`\"{} event. If this field would contain unsafe characters, yauzl emits an error instead of an entry.

If {\ttfamily decode\+Strings} is {\ttfamily false} (see {\ttfamily open()}), this field is the undecoded {\ttfamily Buffer} instead of a decoded {\ttfamily String}. Therefore, {\ttfamily general\+Purpose\+Bit\+Flag} and any Info-\/\+Z\+IP Unicode Path Extra Field are ignored. Furthermore, no automatic file name validation is performed for this file name.

\paragraph*{extra\+Fields}

{\ttfamily Array} with each entry in the form {\ttfamily \{id\+: id, data\+: data\}}, where {\ttfamily id} is a {\ttfamily Number} and {\ttfamily data} is a {\ttfamily Buffer}.

This library looks for and reads the Z\+I\+P64 Extended Information Extra Field (0x0001) in order to support Z\+I\+P64 format zip files.

This library also looks for and reads the Info-\/\+Z\+IP Unicode Path Extra Field (0x7075) in order to support some zipfiles that use it instead of General Purpose Bit 11 to convey {\ttfamily U\+T\+F-\/8} file names. When the field is identified and verified to be reliable (see the zipfile spec), the the file name in this field is stored in the {\ttfamily file\+Name} property, and the file name in the central directory record for this entry is ignored. Note that when {\ttfamily decode\+Strings} is false, all Info-\/\+Z\+IP Unicode Path Extra Fields are ignored.

None of the other fields are considered significant by this library. Fields that this library reads are left unalterned in the {\ttfamily extra\+Fields} array.

\paragraph*{file\+Comment}

{\ttfamily String} decoded with the charset indicated by {\ttfamily general\+Purpose\+Bit\+Flag \& 0x800} as with the {\ttfamily file\+Name}. (The Info-\/\+Z\+IP Unicode Path Extra Field has no effect on the charset used for this field.)

If {\ttfamily decode\+Strings} is {\ttfamily false} (see {\ttfamily open()}), this field is the undecoded {\ttfamily Buffer} instead of a decoded {\ttfamily String}.

Prior to yauzl version 2.\+7.\+0, this field was erroneously documented as {\ttfamily comment} instead of {\ttfamily file\+Comment}. For compatibility with any code that uses the field name {\ttfamily comment}, yauzl creates an alias field named {\ttfamily comment} which is identical to {\ttfamily file\+Comment}.

\paragraph*{get\+Last\+Mod\+Date()}

Effectively implemented as\+:


\begin{DoxyCode}
return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
\end{DoxyCode}


\paragraph*{is\+Encrypted()}

Returns is this entry encrypted with \char`\"{}\+Traditional Encryption\char`\"{}. Effectively implemented as\+:


\begin{DoxyCode}
return (this.generalPurposeBitFlag & 0x1) !== 0;
\end{DoxyCode}


See {\ttfamily open\+Read\+Stream()} for the implications of this value.

Note that \char`\"{}\+Strong Encryption\char`\"{} is not supported, and will result in an {\ttfamily \char`\"{}error\char`\"{}} event emitted from the {\ttfamily Zip\+File}.

\paragraph*{is\+Compressed()}

Effectively implemented as\+:


\begin{DoxyCode}
return this.compressionMethod === 8;
\end{DoxyCode}


See {\ttfamily open\+Read\+Stream()} for the implications of this value.

\subsubsection*{Class\+: Random\+Access\+Reader}

This class is meant to be subclassed by clients and instantiated for the {\ttfamily from\+Random\+Access\+Reader()} function.

An example implementation can be found in {\ttfamily test/test.\+js}.

\paragraph*{random\+Access\+Reader.\+\_\+read\+Stream\+For\+Range(start, end)}

Subclasses {\itshape must} implement this method.

{\ttfamily start} and {\ttfamily end} are Numbers and indicate byte offsets from the start of the file. {\ttfamily end} is exclusive, so {\ttfamily \+\_\+read\+Stream\+For\+Range(0x1000, 0x2000)} would indicate to read {\ttfamily 0x1000} bytes. {\ttfamily end -\/ start} will always be at least {\ttfamily 1}.

This method should return a readable stream which will be {\ttfamily pipe()}ed into another stream. It is expected that the readable stream will provide data in several chunks if necessary. If the readable stream provides too many or too few bytes, an error will be emitted. (Note that {\ttfamily validate\+Entry\+Sizes} has no effect on this check, because this is a low-\/level A\+PI that should behave correctly regardless of the contents of the file.) Any errors emitted on the readable stream will be handled and re-\/emitted on the client-\/visible stream (returned from {\ttfamily zipfile.\+open\+Read\+Stream()}) or provided as the {\ttfamily err} argument to the appropriate callback (for example, for {\ttfamily from\+Random\+Access\+Reader()}).

The returned stream {\itshape must} implement a method {\ttfamily .destroy()} if you call {\ttfamily read\+Stream.\+destroy()} on streams you get from {\ttfamily open\+Read\+Stream()}. If you never call {\ttfamily read\+Stream.\+destroy()}, then streams returned from this method do not need to implement a method {\ttfamily .destroy()}. {\ttfamily .destroy()} should abort any streaming that is in progress and clean up any associated resources. {\ttfamily .destroy()} will only be called after the stream has been {\ttfamily unpipe()}d from its destination.

Note that the stream returned from this method might not be the same object that is provided by {\ttfamily open\+Read\+Stream()}. The stream returned from this method might be {\ttfamily pipe()}d through one or more filter streams (for example, a zlib inflate stream).

\paragraph*{random\+Access\+Reader.\+read(buffer, offset, length, position, callback)}

Subclasses may implement this method. The default implementation uses {\ttfamily create\+Read\+Stream()} to fill the {\ttfamily buffer}.

This method should behave like {\ttfamily fs.\+read()}.

\paragraph*{random\+Access\+Reader.\+close(callback)}

Subclasses may implement this method. The default implementation is effectively {\ttfamily set\+Immediate(callback);}.

{\ttfamily callback} takes parameters {\ttfamily (err)}.

This method is called once the all streams returned from {\ttfamily \+\_\+read\+Stream\+For\+Range()} have ended, and no more {\ttfamily \+\_\+read\+Stream\+For\+Range()} or {\ttfamily read()} requests will be issued to this object.

\subsection*{How to Avoid Crashing}

When a malformed zipfile is encountered, the default behavior is to crash (throw an exception). If you want to handle errors more gracefully than this, be sure to do the following\+:


\begin{DoxyItemize}
\item Provide {\ttfamily callback} parameters where they are allowed, and check the {\ttfamily err} parameter.
\item Attach a listener for the {\ttfamily error} event on any {\ttfamily Zip\+File} object you get from {\ttfamily open()}, {\ttfamily from\+Fd()}, {\ttfamily from\+Buffer()}, or {\ttfamily from\+Random\+Access\+Reader()}.
\item Attach a listener for the {\ttfamily error} event on any stream you get from {\ttfamily open\+Read\+Stream()}.
\end{DoxyItemize}

Minor version updates to yauzl will not add any additional requirements to this list.

\subsection*{Limitations}

\subsubsection*{No Streaming Unzip A\+PI}

Due to the design of the .zip file format, it\textquotesingle{}s impossible to interpret a .zip file from start to finish (such as from a readable stream) without sacrificing correctness. The Central Directory, which is the authority on the contents of the .zip file, is at the end of a .zip file, not the beginning. A streaming A\+PI would need to either buffer the entire .zip file to get to the Central Directory before interpreting anything (defeating the purpose of a streaming interface), or rely on the Local File Headers which are interspersed through the .zip file. However, the Local File Headers are explicitly denounced in the spec as being unreliable copies of the Central Directory, so trusting them would be a violation of the spec.

Any library that offers a streaming unzip A\+PI must make one of the above two compromises, which makes the library either dishonest or nonconformant (usually the latter). This library insists on correctness and adherence to the spec, and so does not offer a streaming A\+PI.

Here is a way to create a spec-\/conformant .zip file using the {\ttfamily zip} command line program (Info-\/\+Z\+IP) available in most unix-\/like environments, that is (nearly) impossible to parse correctly with a streaming parser\+:


\begin{DoxyCode}
$ echo -ne '\(\backslash\)x50\(\backslash\)x4b\(\backslash\)x07\(\backslash\)x08\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00\(\backslash\)x00' > file.txt
$ zip -q0 - file.txt | cat > out.zip
\end{DoxyCode}


This .zip file contains a single file entry that uses General Purpose Bit 3, which means the Local File Header doesn\textquotesingle{}t know the size of the file. Any streaming parser that encounters this situation will either immediately fail, or attempt to search for the Data Descriptor after the file\textquotesingle{}s contents. The file\textquotesingle{}s contents is a sequence of 16-\/bytes crafted to exactly mimic a valid Data Descriptor for an empty file, which will fool any parser that gets this far into thinking that the file is empty rather than containing 16-\/bytes. What follows the file\textquotesingle{}s real contents is the file\textquotesingle{}s real Data Descriptor, which will likely cause some kind of signature mismatch error for a streaming parser (if one hasn\textquotesingle{}t occurred already).

By using General Purpose Bit 3 (and compression method 0), it\textquotesingle{}s possible to create arbitrarily ambiguous .zip files that distract parsers with file contents that contain apparently valid .zip file metadata.

\subsubsection*{Limitted Z\+I\+P64 Support}

For Z\+I\+P64, only zip files smaller than {\ttfamily 8\+PiB} are supported, not the full {\ttfamily 16\+EiB} range that a 64-\/bit integer should be able to index. This is due to the Java\+Script Number type being an I\+E\+EE 754 double precision float.

The Node.\+js {\ttfamily fs} module probably has this same limitation.

\subsubsection*{Z\+I\+P64 Extensible Data Sector Is Ignored}

The spec does not allow zip file creators to put arbitrary data here, but rather reserves its use for P\+K\+W\+A\+RE and mentions something about Z390. This doesn\textquotesingle{}t seem useful to expose in this library, so it is ignored.

\subsubsection*{No Multi-\/\+Disk Archive Support}

This library does not support multi-\/disk zip files. The multi-\/disk fields in the zipfile spec were intended for a zip file to span multiple floppy disks, which probably never happens now. If the \char`\"{}number of this disk\char`\"{} field in the End of Central Directory Record is not {\ttfamily 0}, the {\ttfamily open()}, {\ttfamily from\+Fd()}, {\ttfamily from\+Buffer()}, or {\ttfamily from\+Random\+Access\+Reader()} {\ttfamily callback} will receive an {\ttfamily err}. By extension the following zip file fields are ignored by this library and not provided to clients\+:


\begin{DoxyItemize}
\item Disk where central directory starts
\item Number of central directory records on this disk
\item Disk number where file starts
\end{DoxyItemize}

\subsubsection*{Limited Encryption Handling}

You can detect when a file entry is encrypted with \char`\"{}\+Traditional Encryption\char`\"{} via {\ttfamily is\+Encrypted()}, but yauzl will not help you decrypt it. See {\ttfamily open\+Read\+Stream()}.

If a zip file contains file entries encrypted with \char`\"{}\+Strong Encryption\char`\"{}, yauzl emits an error.

If the central directory is encrypted or compressed, yauzl emits an error.

\subsubsection*{Local File Headers Are Ignored}

Many unzip libraries mistakenly read the Local File Header data in zip files. This data is officially defined to be redundant with the Central Directory information, and is not to be trusted. Aside from checking the signature, yauzl ignores the content of the Local File Header.

\subsubsection*{No C\+R\+C-\/32 Checking}

This library provides the {\ttfamily crc32} field of {\ttfamily Entry} objects read from the Central Directory. However, this field is not used for anything in this library.

\subsubsection*{version\+Needed\+To\+Extract Is Ignored}

The field {\ttfamily version\+Needed\+To\+Extract} is ignored, because this library doesn\textquotesingle{}t support the complete zip file spec at any version,

\subsubsection*{No Support For Obscure Compression Methods}

Regarding the {\ttfamily compression\+Method} field of {\ttfamily Entry} objects, only method {\ttfamily 0} (stored with no compression) and method {\ttfamily 8} (deflated) are supported. Any of the other 15 official methods will cause the {\ttfamily open\+Read\+Stream()} {\ttfamily callback} to receive an {\ttfamily err}.

\subsubsection*{Data Descriptors Are Ignored}

There may or may not be Data Descriptor sections in a zip file. This library provides no support for finding or interpreting them.

\subsubsection*{Archive Extra Data Record Is Ignored}

There may or may not be an Archive Extra Data Record section in a zip file. This library provides no support for finding or interpreting it.

\subsubsection*{No Language Encoding Flag Support}

Zip files officially support charset encodings other than C\+P437 and U\+T\+F-\/8, but the zip file spec does not specify how it works. This library makes no attempt to interpret the Language Encoding Flag.

\subsection*{Change History}


\begin{DoxyItemize}
\item 2.\+10.\+0
\begin{DoxyItemize}
\item Added support for non-\/conformant zipfiles created by Microsoft, and added option {\ttfamily strict\+File\+Names} to disable the workaround. \href{https://github.com/thejoshwolfe/yauzl/issues/66}{\tt issue \#66}, \href{https://github.com/thejoshwolfe/yauzl/issues/88}{\tt issue \#88}
\end{DoxyItemize}
\item 2.\+9.\+2
\begin{DoxyItemize}
\item Removed {\ttfamily tools/hexdump-\/zip.\+js} and {\ttfamily tools/hex2bin.\+js}. Those tools are now located here\+: \href{https://github.com/thejoshwolfe/hexdump-zip}{\tt thejoshwolfe/hexdump-\/zip} and \href{https://github.com/thejoshwolfe/hex2bin}{\tt thejoshwolfe/hex2bin}
\item Worked around performance problem with zlib when using {\ttfamily from\+Buffer()} and {\ttfamily read\+Stream.\+destroy()} for large compressed files. \href{https://github.com/thejoshwolfe/yauzl/issues/87}{\tt issue \#87}
\end{DoxyItemize}
\item 2.\+9.\+1
\begin{DoxyItemize}
\item Removed {\ttfamily console.\+log()} accidentally introduced in 2.\+9.\+0. \href{https://github.com/thejoshwolfe/yauzl/issues/64}{\tt issue \#64}
\end{DoxyItemize}
\item 2.\+9.\+0
\begin{DoxyItemize}
\item Throw an exception if {\ttfamily read\+Entry()} is called without {\ttfamily lazy\+Entries\+:true}. Previously this caused undefined behavior. \href{https://github.com/thejoshwolfe/yauzl/issues/63}{\tt issue \#63}
\end{DoxyItemize}
\item 2.\+8.\+0
\begin{DoxyItemize}
\item Added option {\ttfamily validate\+Entry\+Sizes}. \href{https://github.com/thejoshwolfe/yauzl/issues/53}{\tt issue \#53}
\item Added {\ttfamily examples/promises.\+js}
\item Added ability to read raw file data via {\ttfamily decompress} and {\ttfamily decrypt} options. \href{https://github.com/thejoshwolfe/yauzl/issues/11}{\tt issue \#11}, \href{https://github.com/thejoshwolfe/yauzl/issues/38}{\tt issue \#38}, \href{https://github.com/thejoshwolfe/yauzl/pull/39}{\tt pull \#39}
\item Added {\ttfamily start} and {\ttfamily end} options to {\ttfamily open\+Read\+Stream()}. \href{https://github.com/thejoshwolfe/yauzl/issues/38}{\tt issue \#38}
\end{DoxyItemize}
\item 2.\+7.\+0
\begin{DoxyItemize}
\item Added option {\ttfamily decode\+Strings}. \href{https://github.com/thejoshwolfe/yauzl/issues/42}{\tt issue \#42}
\item Fixed documentation for {\ttfamily entry.\+file\+Comment} and added compatibility alias. \href{https://github.com/thejoshwolfe/yauzl/issues/47}{\tt issue \#47}
\end{DoxyItemize}
\item 2.\+6.\+0
\begin{DoxyItemize}
\item Support Info-\/\+Z\+IP Unicode Path Extra Field, used by Win\+R\+AR for Chinese file names. \href{https://github.com/thejoshwolfe/yauzl/issues/33}{\tt issue \#33}
\end{DoxyItemize}
\item 2.\+5.\+0
\begin{DoxyItemize}
\item Ignore malformed Extra Field that is common in Android .apk files. \href{https://github.com/thejoshwolfe/yauzl/issues/31}{\tt issue \#31}
\end{DoxyItemize}
\item 2.\+4.\+3
\begin{DoxyItemize}
\item Fix crash when parsing malformed Extra Field buffers. \href{https://github.com/thejoshwolfe/yauzl/issues/31}{\tt issue \#31}
\end{DoxyItemize}
\item 2.\+4.\+2
\begin{DoxyItemize}
\item Remove .npmignore and .travis.\+yml from npm package.
\end{DoxyItemize}
\item 2.\+4.\+1
\begin{DoxyItemize}
\item Fix error handling.
\end{DoxyItemize}
\item 2.\+4.\+0
\begin{DoxyItemize}
\item Add Z\+I\+P64 support. \href{https://github.com/thejoshwolfe/yauzl/issues/6}{\tt issue \#6}
\item Add {\ttfamily lazy\+Entries} option. \href{https://github.com/thejoshwolfe/yauzl/issues/22}{\tt issue \#22}
\item Add {\ttfamily read\+Stream.\+destroy()} method. \href{https://github.com/thejoshwolfe/yauzl/issues/26}{\tt issue \#26}
\item Add {\ttfamily from\+Random\+Access\+Reader()}. \href{https://github.com/thejoshwolfe/yauzl/issues/14}{\tt issue \#14}
\item Add {\ttfamily examples/unzip.\+js}.
\end{DoxyItemize}
\item 2.\+3.\+1
\begin{DoxyItemize}
\item Documentation updates.
\end{DoxyItemize}
\item 2.\+3.\+0
\begin{DoxyItemize}
\item Check that {\ttfamily uncompressed\+Size} is correct, or else emit an error. \href{https://github.com/thejoshwolfe/yauzl/issues/13}{\tt issue \#13}
\end{DoxyItemize}
\item 2.\+2.\+1
\begin{DoxyItemize}
\item Update dependencies.
\end{DoxyItemize}
\item 2.\+2.\+0
\begin{DoxyItemize}
\item Update dependencies.
\end{DoxyItemize}
\item 2.\+1.\+0
\begin{DoxyItemize}
\item Remove dependency on {\ttfamily iconv}.
\end{DoxyItemize}
\item 2.\+0.\+3
\begin{DoxyItemize}
\item Fix crash when trying to read a 0-\/byte file.
\end{DoxyItemize}
\item 2.\+0.\+2
\begin{DoxyItemize}
\item Fix event behavior after errors.
\end{DoxyItemize}
\item 2.\+0.\+1
\begin{DoxyItemize}
\item Fix bug with using {\ttfamily iconv}.
\end{DoxyItemize}
\item 2.\+0.\+0
\begin{DoxyItemize}
\item Initial release. 
\end{DoxyItemize}
\end{DoxyItemize}