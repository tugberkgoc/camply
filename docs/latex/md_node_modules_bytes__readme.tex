\href{https://npmjs.org/package/bytes}{\tt } \href{https://npmjs.org/package/bytes}{\tt } \href{https://travis-ci.org/visionmedia/bytes.js}{\tt } \href{https://coveralls.io/r/visionmedia/bytes.js?branch=master}{\tt }

Utility to parse a string bytes (ex\+: {\ttfamily 1\+TB}) to bytes ({\ttfamily 1099511627776}) and vice-\/versa.

\subsection*{Installation}

This is a \href{https://nodejs.org/en/}{\tt Node.\+js} module available through the \href{https://www.npmjs.com/}{\tt npm registry}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\tt {\ttfamily npm install} command}\+:


\begin{DoxyCode}
$ npm install bytes
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var bytes = require('bytes');
\end{DoxyCode}


\paragraph*{bytes.\+format(number value, \mbox{[}options\mbox{]})\+: string｜null}

Format the given value in bytes into a string. If the value is negative, it is kept as such. If it is a float, it is rounded.

{\bfseries Arguments}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endhead
value  &{\ttfamily number}  &Value in bytes   \\\cline{1-3}
options  &{\ttfamily Object}  &Conversion options   \\\cline{1-3}
\end{longtabu}


{\bfseries Options}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Property  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Property  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endhead
decimal\+Places  &{\ttfamily number}｜{\ttfamily null}  &Maximum number of decimal places to include in output. Default value to {\ttfamily 2}.   \\\cline{1-3}
fixed\+Decimals  &{\ttfamily boolean}｜{\ttfamily null}  &Whether to always display the maximum number of decimal places. Default value to {\ttfamily false}   \\\cline{1-3}
thousands\+Separator  &{\ttfamily string}｜{\ttfamily null}  &Example of values\+: `' \textquotesingle{}{\ttfamily ,}\textquotesingle{},\textquotesingle{}{\ttfamily and}.{\ttfamily ... Default value to}\textquotesingle{}\textquotesingle{}\`{}.   \\\cline{1-3}
unit  &{\ttfamily string}｜{\ttfamily null}  &The unit in which the result will be returned (B/\+K\+B/\+M\+B/\+G\+B/\+TB). Default value to `'\textquotesingle{}\`{} (which means auto detect).   \\\cline{1-3}
unit\+Separator  &{\ttfamily string}｜{\ttfamily null}  &Separator to use between number and unit. Default value to `'\textquotesingle{}\`{}.   \\\cline{1-3}
\end{longtabu}


{\bfseries Returns}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endhead
results  &{\ttfamily string}｜{\ttfamily null}  &Return null upon error. String value otherwise.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example}


\begin{DoxyCode}
bytes(1024);
// output: '1KB'

bytes(1000);
// output: '1000B'

bytes(1000, \{thousandsSeparator: ' '\});
// output: '1 000B'

bytes(1024 * 1.7, \{decimalPlaces: 0\});
// output: '2KB'

bytes(1024, \{unitSeparator: ' '\});
// output: '1 KB'
\end{DoxyCode}


\paragraph*{bytes.\+parse(string｜number value)\+: number｜null}

Parse the string value into an integer in bytes. If no unit is given, or {\ttfamily value} is a number, it is assumed the value is in bytes.

Supported units and abbreviations are as follows and are case-\/insensitive\+:


\begin{DoxyItemize}
\item {\ttfamily b} for bytes
\item {\ttfamily kb} for kilobytes
\item {\ttfamily mb} for megabytes
\item {\ttfamily gb} for gigabytes
\item {\ttfamily tb} for terabytes
\end{DoxyItemize}

The units are in powers of two, not ten. This means 1kb = 1024b according to this parser.

{\bfseries Arguments}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endhead
value  &{\ttfamily string}｜{\ttfamily number}  &String to parse, or number in bytes.   \\\cline{1-3}
\end{longtabu}


{\bfseries Returns}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ Description   }\\\cline{1-3}
\endhead
results  &{\ttfamily number}｜{\ttfamily null}  &Return null upon error. Value in bytes otherwise.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example}


\begin{DoxyCode}
bytes('1KB');
// output: 1024

bytes('1024');
// output: 1024

bytes(1024);
// output: 1024
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 