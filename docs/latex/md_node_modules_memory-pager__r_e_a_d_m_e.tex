Access memory using small fixed sized buffers instead of allocating a huge buffer. Useful if you are implementing sparse data structures (such as large bitfield).




\begin{DoxyCode}
npm install memory-pager
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var pager = require('paged-memory')

var pages = pager(1024) // use 1kb per page

var page = pages.get(10) // get page #10

console.log(page.offset) // 10240
console.log(page.buffer) // a blank 1kb buffer
\end{DoxyCode}


\subsection*{A\+PI}

\paragraph*{{\ttfamily var pages = pager(page\+Size)}}

Create a new pager. {\ttfamily page\+Size} defaults to {\ttfamily 1024}.

\paragraph*{{\ttfamily var page = pages.\+get(page\+Number, \mbox{[}no\+Allocate\mbox{]})}}

Get a page. The page will be allocated at first access.

Optionally you can set the {\ttfamily no\+Allocate} flag which will make the method return undefined if no page has been allocated already

A page looks like this


\begin{DoxyCode}
\{
  offset: byteOffset,
  buffer: bufferWithPageSize
\}
\end{DoxyCode}


\paragraph*{{\ttfamily pages.\+set(page\+Number, buffer)}}

Explicitly set the buffer for a page.

\paragraph*{{\ttfamily pages.\+updated(page)}}

Mark a page as updated.

\paragraph*{{\ttfamily pages.\+last\+Update()}}

Get the last page that was updated.

\paragraph*{{\ttfamily var buf = pages.\+to\+Buffer()}}

Concat all pages allocated pages into a single buffer

\subsection*{License}

M\+IT 